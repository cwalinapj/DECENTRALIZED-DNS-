[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261635","pull_request_review_id":3818719762,"id":2821261635,"node_id":"PRRC_kwDORKbd9s6oKQlD","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {\n+            require!(\n+                now_slot >= rep.last_claim_slot.saturating_add(cfg.cooldown_slots),\n+                RepError::CooldownNotMet\n+            );\n+        }\n+\n+        if rep.rep_today_day_id != now_day {\n+            rep.rep_today_day_id = now_day;\n+            rep.rep_today = 0;\n+        }\n+\n+        if cfg.rep_decay_per_epoch > 0 && rep.last_epoch_seen > 0 && epoch_id > rep.last_epoch_seen {\n+            let elapsed = epoch_id.saturating_sub(rep.last_epoch_seen);\n+            let decay = cfg\n+                .rep_decay_per_epoch\n+                .saturating_mul(elapsed)\n+                .min(rep.rep_total);\n+            rep.rep_total = rep.rep_total.saturating_sub(decay);\n+        }\n+\n+        let bonus_bps = compute_diversity_bonus_bps(cfg, unique_name_hashes, unique_colos);\n+        let raw_award = ((cfg.rep_per_valid_aggregate as u128)\n+            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n+            .ok_or(error!(RepError::MathOverflow))?\n+            / BONUS_DENOM) as u64;\n+\n+        let remaining_today = cfg.daily_rep_cap_per_miner.saturating_sub(rep.rep_today);\n+        let award = raw_award.min(remaining_today);\n+        require!(award > 0, RepError::DailyCapReached);\n+\n+        rep.rep_total = rep.rep_total.saturating_add(award);\n+        rep.rep_today = rep.rep_today.saturating_add(award);","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`rep_total` and `rep_today` are updated with `saturating_add`, which will silently clamp on overflow. For an on-chain accounting value this makes it hard to reason about correctness and can hide misconfiguration. Prefer `checked_add` (with a `MathOverflow` error) or otherwise enforce caps so overflow cannot occur.\n```suggestion\n        rep.rep_total = rep\n            .rep_total\n            .checked_add(award)\n            .ok_or(error!(RepError::MathOverflow))?;\n        rep.rep_today = rep\n            .rep_today\n            .checked_add(award)\n            .ok_or(error!(RepError::MathOverflow))?;\n```","created_at":"2026-02-18T09:27:08Z","updated_at":"2026-02-18T09:27:12Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261635","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261635"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261635"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261635/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":173,"original_start_line":173,"start_side":"RIGHT","line":174,"original_line":174,"side":"RIGHT","author_association":"NONE","original_position":174,"position":174,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261661","pull_request_review_id":3818719762,"id":2821261661,"node_id":"PRRC_kwDORKbd9s6oKQld","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The “duplicate receipts root” guard only compares against `rep.last_receipts_root` (the immediately previous submission). A miner can bypass this by alternating between two different roots (or using arbitrary roots) and still call `award_rep` repeatedly until the daily cap is hit. If the intent is to prevent reusing the same committed receipts for multiple awards, consider tracking used roots per `(miner, epoch_id)` (e.g., a dedicated PDA keyed by `receipts_root`) or otherwise binding the award to a unique on-chain state transition.","created_at":"2026-02-18T09:27:09Z","updated_at":"2026-02-18T09:27:13Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261661","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261661"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261661"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261661/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":139,"original_start_line":139,"start_side":"RIGHT","line":142,"original_line":142,"side":"RIGHT","author_association":"NONE","original_position":142,"position":142,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261691","pull_request_review_id":3818719762,"id":2821261691,"node_id":"PRRC_kwDORKbd9s6oKQl7","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`award_rep` is fully miner-self-attested: `unique_name_hashes`, `unique_colos`, and `receipts_root` are provided by the miner and there is no allowlist, authority signature, or on-chain verification tying the award to a validated aggregate. This means any miner who meets the bond can mint themselves up to the daily cap with arbitrary inputs. If rewards are intended to be granted only after off-chain validation (consistent with other MVP programs like `ddns_miner_score` using allowlisted submitters), add an authorization gate (allowlist / authority signer / verifier signature instruction) or a verifiable proof mechanism.","created_at":"2026-02-18T09:27:09Z","updated_at":"2026-02-18T09:27:14Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261691","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261691"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261691"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261691/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":105,"original_start_line":105,"start_side":"RIGHT","line":123,"original_line":123,"side":"RIGHT","author_association":"NONE","original_position":123,"position":123,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261708","pull_request_review_id":3818719762,"id":2821261708,"node_id":"PRRC_kwDORKbd9s6oKQmM","diff_hunk":"@@ -0,0 +1,168 @@\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { Program } from \"@coral-xyz/anchor\";\n+import { expect } from \"chai\";\n+import { Keypair, PublicKey, SystemProgram, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n+import BN from \"bn.js\";\n+\n+function u64le(n: bigint): Buffer {\n+  const b = Buffer.alloc(8);\n+  b.writeBigUInt64LE(n);\n+  return b;\n+}\n+","path":"solana/tests/ddns_rep.ts","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"This test suite defines `u64le` but never uses it. Removing unused helpers avoids lint noise and makes it clearer what’s required for the test.\n```suggestion\n\n```","created_at":"2026-02-18T09:27:09Z","updated_at":"2026-02-18T09:27:14Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261708","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261708"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261708"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261708/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":7,"original_start_line":7,"start_side":"RIGHT","line":12,"original_line":12,"side":"RIGHT","author_association":"NONE","original_position":12,"position":12,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261734","pull_request_review_id":3818719762,"id":2821261734,"node_id":"PRRC_kwDORKbd9s6oKQmm","diff_hunk":"@@ -0,0 +1,168 @@\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { Program } from \"@coral-xyz/anchor\";\n+import { expect } from \"chai\";\n+import { Keypair, PublicKey, SystemProgram, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n+import BN from \"bn.js\";\n+\n+function u64le(n: bigint): Buffer {\n+  const b = Buffer.alloc(8);\n+  b.writeBigUInt64LE(n);\n+  return b;\n+}\n+\n+describe(\"ddns_rep\", () => {\n+  const provider = anchor.AnchorProvider.env();\n+  anchor.setProvider(provider);\n+\n+  const program = anchor.workspace.DdnsRep as Program;\n+\n+  it(\"bond gate + award rep + daily cap + duplicate root\", async () => {\n+    const feePayer = (provider.wallet as any).payer as Keypair;\n+    const authority = feePayer.publicKey;\n+\n+    const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+\n+    await program.methods\n+      .initRepConfig(\n+        new BN(1000), // epoch_len_slots\n+        new BN(50), // daily cap\n+        new BN(10_000_000), // min bond\n+        2, // min unique names\n+        1, // min unique colos\n+        new BN(40), // rep per valid aggregate\n+        new BN(0), // no decay\n+        new BN(0), // cooldown slots\n+        true\n+      )\n+      .accounts({\n+        authority,\n+        config: configPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .rpc();\n+\n+    const miner = Keypair.generate();\n+    const dropSig = await provider.connection.requestAirdrop(miner.publicKey, LAMPORTS_PER_SOL);\n+    await provider.connection.confirmTransaction(dropSig, \"confirmed\");\n+\n+    const [bondPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"rep_bond\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+    const [repPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"miner_rep\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+\n+    await program.methods\n+      .depositRepBond(new BN(20_000_000))\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    const slot = await provider.connection.getSlot(\"confirmed\");\n+    const epoch = BigInt(Math.floor(slot / 1000));\n+\n+    const rootA = Array.from({ length: 32 }, (_, i) => (i + 1) % 255);\n+    await program.methods\n+      .awardRep(new BN(epoch.toString()), rootA, 100, 2, 1)\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        rep: repPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    // duplicate root must fail\n+    try {\n+      await program.methods\n+        .awardRep(new BN(epoch.toString()), rootA, 100, 2, 1)\n+        .accounts({\n+          miner: miner.publicKey,\n+          config: configPda,\n+          bond: bondPda,\n+          rep: repPda,\n+          systemProgram: SystemProgram.programId,\n+        })\n+        .signers([miner])\n+        .rpc();\n+      expect.fail(\"expected duplicate root failure\");\n+    } catch (e: any) {\n+      expect(String(e)).to.match(/DuplicateRoot|duplicate/i);\n+    }\n+\n+    // second unique root should be capped by daily cap (50 total).\n+    const rootB = Array.from({ length: 32 }, (_, i) => (i + 2) % 255);\n+    await program.methods\n+      .awardRep(new BN(epoch.toString()), rootB, 100, 10, 2)\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        rep: repPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    const rep: any = await program.account.minerRep.fetch(repPda);\n+    expect(Number(rep.repTotal)).to.equal(50);\n+    expect(Number(rep.repToday)).to.equal(50);\n+  });\n+\n+  it(\"rejects award when diversity below minimum\", async () => {\n+    const miner = Keypair.generate();\n+    const dropSig = await provider.connection.requestAirdrop(miner.publicKey, LAMPORTS_PER_SOL);\n+    await provider.connection.confirmTransaction(dropSig, \"confirmed\");\n+\n+    const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+    const [bondPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"rep_bond\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+    const [repPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"miner_rep\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+\n+    await program.methods\n+      .depositRepBond(new BN(20_000_000))\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+","path":"solana/tests/ddns_rep.ts","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The second test assumes `rep_config` has already been initialized by the first test (it calls `depositRepBond` with `config: configPda` but never runs `initRepConfig`). This makes the file order-dependent and brittle if tests are run in isolation or if the first test fails early. Move config initialization to a `before` hook (or explicitly initialize/fetch-and-skip in each test).","created_at":"2026-02-18T09:27:10Z","updated_at":"2026-02-18T09:27:14Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261734","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261734"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261734"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261734/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":121,"original_start_line":121,"start_side":"RIGHT","line":146,"original_line":146,"side":"RIGHT","author_association":"NONE","original_position":146,"position":146,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261751","pull_request_review_id":3818719762,"id":2821261751,"node_id":"PRRC_kwDORKbd9s6oKQm3","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {\n+            require!(\n+                now_slot >= rep.last_claim_slot.saturating_add(cfg.cooldown_slots),\n+                RepError::CooldownNotMet\n+            );\n+        }\n+\n+        if rep.rep_today_day_id != now_day {\n+            rep.rep_today_day_id = now_day;\n+            rep.rep_today = 0;\n+        }\n+\n+        if cfg.rep_decay_per_epoch > 0 && rep.last_epoch_seen > 0 && epoch_id > rep.last_epoch_seen {\n+            let elapsed = epoch_id.saturating_sub(rep.last_epoch_seen);\n+            let decay = cfg\n+                .rep_decay_per_epoch\n+                .saturating_mul(elapsed)\n+                .min(rep.rep_total);\n+            rep.rep_total = rep.rep_total.saturating_sub(decay);\n+        }\n+\n+        let bonus_bps = compute_diversity_bonus_bps(cfg, unique_name_hashes, unique_colos);\n+        let raw_award = ((cfg.rep_per_valid_aggregate as u128)\n+            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n+            .ok_or(error!(RepError::MathOverflow))?\n+            / BONUS_DENOM) as u64;\n+\n+        let remaining_today = cfg.daily_rep_cap_per_miner.saturating_sub(rep.rep_today);\n+        let award = raw_award.min(remaining_today);\n+        require!(award > 0, RepError::DailyCapReached);\n+\n+        rep.rep_total = rep.rep_total.saturating_add(award);\n+        rep.rep_today = rep.rep_today.saturating_add(award);\n+        rep.last_epoch_seen = epoch_id;\n+        rep.last_claim_slot = now_slot;\n+        rep.last_receipts_root = receipts_root;\n+\n+        emit!(RepAwarded {\n+            miner: ctx.accounts.miner.key(),\n+            epoch_id,\n+            awarded: award,\n+            bonus_bps,\n+            rep_total: rep.rep_total,\n+            rep_today: rep.rep_today,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn slash_rep_bond(\n+        ctx: Context<SlashRepBond>,\n+        slash_lamports: u64,\n+        strike_inc: u32,\n+    ) -> Result<()> {\n+        require!(slash_lamports > 0 || strike_inc > 0, RepError::InvalidAmount);\n+\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        if slash_lamports > 0 {\n+            require!(bond_view.bond_lamports >= slash_lamports, RepError::InsufficientBond);\n+\n+            let rent = Rent::get()?;\n+            let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+            require!(\n+                current.saturating_sub(slash_lamports) >= min_lamports,\n+                RepError::BondRentViolation\n+            );\n+\n+            **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= slash_lamports;\n+            **ctx.accounts.slash_destination.to_account_info().try_borrow_mut_lamports()? += slash_lamports;\n+            let bond = &mut ctx.accounts.bond;\n+            bond.bond_lamports = bond\n+                .bond_lamports\n+                .checked_sub(slash_lamports)\n+                .ok_or(error!(RepError::MathOverflow))?;\n+        }\n+\n+        if strike_inc > 0 {\n+            let rep = &mut ctx.accounts.rep;\n+            rep.strikes = rep.strikes.saturating_add(strike_inc);\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitRepConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + RepConfig::SIZE,\n+        seeds = [b\"rep_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct DepositRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerBond::SIZE,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct WithdrawRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct AwardRep<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerRep::SIZE,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub rep: Account<'info, MinerRep>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SlashRepBond<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    /// CHECK: any lamports destination\n+    #[account(mut)]\n+    pub slash_destination: UncheckedAccount<'info>,\n+    /// CHECK: used only as PDA seed target for bond/rep and does not require owner/type checks.\n+    #[account(mut)]\n+    pub miner: UncheckedAccount<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        mut,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump = rep.bump,\n+    )]\n+    pub rep: Account<'info, MinerRep>,","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`slash_rep_bond` always requires the `rep` account, but `MinerRep` is only created via `award_rep` (`init_if_needed` there). That means the authority cannot slash a miner’s bond (lamports) unless the miner has previously created a `MinerRep` account, even when `strike_inc == 0`. Consider making `rep` optional/`init_if_needed` (payer = authority) or splitting the instruction so bond slashing doesn’t depend on `MinerRep` existing.\n```suggestion\n        init_if_needed,\n        payer = authority,\n        space = 8 + MinerRep::SIZE,\n        seeds = [b\"miner_rep\", miner.key().as_ref()],\n        bump = rep.bump,\n    )]\n    pub rep: Account<'info, MinerRep>,\n    pub system_program: Program<'info, System>,\n```","created_at":"2026-02-18T09:27:10Z","updated_at":"2026-02-18T09:27:14Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261751","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261751"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261751"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261751/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":335,"original_start_line":335,"start_side":"RIGHT","line":339,"original_line":339,"side":"RIGHT","author_association":"NONE","original_position":339,"position":339,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261782","pull_request_review_id":3818719762,"id":2821261782,"node_id":"PRRC_kwDORKbd9s6oKQnW","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {\n+            require!(\n+                now_slot >= rep.last_claim_slot.saturating_add(cfg.cooldown_slots),\n+                RepError::CooldownNotMet\n+            );\n+        }\n+\n+        if rep.rep_today_day_id != now_day {\n+            rep.rep_today_day_id = now_day;\n+            rep.rep_today = 0;\n+        }\n+\n+        if cfg.rep_decay_per_epoch > 0 && rep.last_epoch_seen > 0 && epoch_id > rep.last_epoch_seen {\n+            let elapsed = epoch_id.saturating_sub(rep.last_epoch_seen);\n+            let decay = cfg\n+                .rep_decay_per_epoch\n+                .saturating_mul(elapsed)\n+                .min(rep.rep_total);\n+            rep.rep_total = rep.rep_total.saturating_sub(decay);\n+        }\n+\n+        let bonus_bps = compute_diversity_bonus_bps(cfg, unique_name_hashes, unique_colos);\n+        let raw_award = ((cfg.rep_per_valid_aggregate as u128)\n+            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n+            .ok_or(error!(RepError::MathOverflow))?\n+            / BONUS_DENOM) as u64;\n+\n+        let remaining_today = cfg.daily_rep_cap_per_miner.saturating_sub(rep.rep_today);\n+        let award = raw_award.min(remaining_today);\n+        require!(award > 0, RepError::DailyCapReached);\n+\n+        rep.rep_total = rep.rep_total.saturating_add(award);\n+        rep.rep_today = rep.rep_today.saturating_add(award);\n+        rep.last_epoch_seen = epoch_id;\n+        rep.last_claim_slot = now_slot;\n+        rep.last_receipts_root = receipts_root;\n+\n+        emit!(RepAwarded {\n+            miner: ctx.accounts.miner.key(),\n+            epoch_id,\n+            awarded: award,\n+            bonus_bps,\n+            rep_total: rep.rep_total,\n+            rep_today: rep.rep_today,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn slash_rep_bond(\n+        ctx: Context<SlashRepBond>,\n+        slash_lamports: u64,\n+        strike_inc: u32,\n+    ) -> Result<()> {\n+        require!(slash_lamports > 0 || strike_inc > 0, RepError::InvalidAmount);\n+\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        if slash_lamports > 0 {\n+            require!(bond_view.bond_lamports >= slash_lamports, RepError::InsufficientBond);\n+\n+            let rent = Rent::get()?;\n+            let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+            require!(\n+                current.saturating_sub(slash_lamports) >= min_lamports,\n+                RepError::BondRentViolation\n+            );\n+\n+            **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= slash_lamports;\n+            **ctx.accounts.slash_destination.to_account_info().try_borrow_mut_lamports()? += slash_lamports;\n+            let bond = &mut ctx.accounts.bond;\n+            bond.bond_lamports = bond\n+                .bond_lamports\n+                .checked_sub(slash_lamports)\n+                .ok_or(error!(RepError::MathOverflow))?;\n+        }\n+\n+        if strike_inc > 0 {\n+            let rep = &mut ctx.accounts.rep;\n+            rep.strikes = rep.strikes.saturating_add(strike_inc);\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitRepConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + RepConfig::SIZE,\n+        seeds = [b\"rep_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct DepositRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerBond::SIZE,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct WithdrawRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct AwardRep<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerRep::SIZE,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub rep: Account<'info, MinerRep>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SlashRepBond<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    /// CHECK: any lamports destination\n+    #[account(mut)]\n+    pub slash_destination: UncheckedAccount<'info>,\n+    /// CHECK: used only as PDA seed target for bond/rep and does not require owner/type checks.\n+    #[account(mut)]\n+    pub miner: UncheckedAccount<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        mut,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump = rep.bump,\n+    )]\n+    pub rep: Account<'info, MinerRep>,\n+}\n+\n+#[account]\n+pub struct RepConfig {\n+    pub authority: Pubkey,\n+    pub epoch_len_slots: u64,\n+    pub daily_rep_cap_per_miner: u64,\n+    pub min_bond_lamports: u64,\n+    pub min_unique_name_hashes: u32,\n+    pub min_unique_colos: u16,\n+    pub rep_per_valid_aggregate: u64,\n+    pub rep_decay_per_epoch: u64,\n+    pub cooldown_slots: u64,\n+    pub enabled: bool,\n+    pub bump: u8,\n+}\n+\n+impl RepConfig {\n+    pub const SIZE: usize = 32 + 8 + 8 + 8 + 4 + 2 + 8 + 8 + 8 + 1 + 1;\n+}\n+\n+#[account]\n+pub struct MinerBond {\n+    pub miner: Pubkey,\n+    pub bond_lamports: u64,\n+    pub last_deposit_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl MinerBond {\n+    pub const SIZE: usize = 32 + 8 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct MinerRep {\n+    pub miner: Pubkey,\n+    pub rep_total: u64,\n+    pub rep_today: u64,\n+    pub rep_today_day_id: u64,\n+    pub last_epoch_seen: u64,\n+    pub strikes: u32,\n+    pub last_claim_slot: u64,\n+    pub last_receipts_root: [u8; 32],\n+    pub bump: u8,\n+}\n+\n+impl MinerRep {\n+    pub const SIZE: usize = 32 + 8 + 8 + 8 + 8 + 4 + 8 + 32 + 1;\n+}\n+\n+#[event]\n+pub struct RepAwarded {\n+    pub miner: Pubkey,\n+    pub epoch_id: u64,\n+    pub awarded: u64,\n+    pub bonus_bps: u16,\n+    pub rep_total: u64,\n+    pub rep_today: u64,\n+}\n+\n+#[error_code]\n+pub enum RepError {\n+    #[msg(\"Invalid config\")]\n+    InvalidConfig,\n+    #[msg(\"Unauthorized\")]\n+    Unauthorized,\n+    #[msg(\"Invalid amount\")]\n+    InvalidAmount,\n+    #[msg(\"Math overflow\")]\n+    MathOverflow,\n+    #[msg(\"Disabled\")]\n+    Disabled,\n+    #[msg(\"Invalid miner\")]\n+    InvalidMiner,\n+    #[msg(\"Insufficient bond\")]\n+    InsufficientBond,\n+    #[msg(\"Cooldown not met\")]\n+    CooldownNotMet,\n+    #[msg(\"Bond rent-exemption violation\")]\n+    BondRentViolation,\n+    #[msg(\"Diversity too low\")]\n+    DiversityTooLow,\n+    #[msg(\"Daily cap reached\")]\n+    DailyCapReached,\n+    #[msg(\"Duplicate receipts root\")]\n+    DuplicateRoot,\n+    #[msg(\"Bad epoch\")]\n+    BadEpoch,\n+}\n+\n+fn day_id(unix_ts: i64) -> Result<u64> {\n+    require!(unix_ts >= 0, RepError::InvalidConfig);\n+    Ok((unix_ts as u64) / 86_400)\n+}\n+\n+fn compute_diversity_bonus_bps(cfg: &RepConfig, names: u32, colos: u16) -> u16 {\n+    let name_excess = names.saturating_sub(cfg.min_unique_name_hashes);\n+    let colo_excess = colos.saturating_sub(cfg.min_unique_colos);\n+    let name_bonus = name_excess.saturating_mul(20); // 0.2% per extra unique name\n+    let colo_bonus = (colo_excess as u32).saturating_mul(100); // 1% per extra colo\n+    (name_bonus.saturating_add(colo_bonus) as u16).min(MAX_BONUS_BPS)","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`compute_diversity_bonus_bps` casts the summed bonus from `u32` to `u16` before applying the `MAX_BONUS_BPS` cap. If `name_bonus + colo_bonus` exceeds `u16::MAX`, the cast truncates and can yield an unexpectedly small bonus (bypassing the intended cap behavior). Compute/cap in a wider integer type first, then cast to `u16` after clamping to `MAX_BONUS_BPS`.\n```suggestion\n    let total_bonus = name_bonus.saturating_add(colo_bonus);\n    total_bonus.min(MAX_BONUS_BPS as u32) as u16\n```","created_at":"2026-02-18T09:27:10Z","updated_at":"2026-02-18T09:27:14Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261782","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261782"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261782"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261782/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":440,"original_line":440,"side":"RIGHT","author_association":"NONE","original_position":440,"position":440,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261815","pull_request_review_id":3818719762,"id":2821261815,"node_id":"PRRC_kwDORKbd9s6oKQn3","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {\n+            require!(\n+                now_slot >= rep.last_claim_slot.saturating_add(cfg.cooldown_slots),\n+                RepError::CooldownNotMet\n+            );\n+        }\n+\n+        if rep.rep_today_day_id != now_day {\n+            rep.rep_today_day_id = now_day;\n+            rep.rep_today = 0;\n+        }\n+\n+        if cfg.rep_decay_per_epoch > 0 && rep.last_epoch_seen > 0 && epoch_id > rep.last_epoch_seen {\n+            let elapsed = epoch_id.saturating_sub(rep.last_epoch_seen);\n+            let decay = cfg\n+                .rep_decay_per_epoch\n+                .saturating_mul(elapsed)\n+                .min(rep.rep_total);\n+            rep.rep_total = rep.rep_total.saturating_sub(decay);\n+        }\n+\n+        let bonus_bps = compute_diversity_bonus_bps(cfg, unique_name_hashes, unique_colos);\n+        let raw_award = ((cfg.rep_per_valid_aggregate as u128)\n+            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n+            .ok_or(error!(RepError::MathOverflow))?\n+            / BONUS_DENOM) as u64;","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","original_commit_id":"3be31c1153aa1bb8f3dc4782418ec6a320cdb6c6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`raw_award` is computed as `u128` and then cast to `u64` with `as u64`. If the configured `rep_per_valid_aggregate` is large enough, this cast will truncate and produce an incorrect award amount without error. Add an explicit bound check (or constrain config values) so `raw_award` cannot exceed `u64::MAX` before converting.\n```suggestion\n        let raw_award_u128 = (cfg.rep_per_valid_aggregate as u128)\n            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n            .ok_or(error!(RepError::MathOverflow))?\n            / BONUS_DENOM;\n        require!(\n            raw_award_u128 <= u64::MAX as u128,\n            RepError::MathOverflow\n        );\n        let raw_award = raw_award_u128 as u64;\n```","created_at":"2026-02-18T09:27:10Z","updated_at":"2026-02-18T09:27:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261815","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261815"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/63#discussion_r2821261815"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/63"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821261815/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":164,"original_start_line":164,"start_side":"RIGHT","line":167,"original_line":167,"side":"RIGHT","author_association":"NONE","original_position":167,"position":167,"subject_type":"line"}]