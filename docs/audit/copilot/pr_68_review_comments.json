[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628583","pull_request_review_id":3819136936,"id":2821628583,"node_id":"PRRC_kwDORKbd9s6oLqKn","diff_hunk":"@@ -0,0 +1,175 @@\n+type Env = {\n+  UPSTREAMS?: string;\n+  TIMEOUT_MS?: string;\n+  OVERLAP_RATIO?: string;\n+  RECEIPT_ENDPOINT?: string;\n+};\n+\n+type UpstreamHit = {\n+  url: string;\n+  rtt_ms: number;\n+  status: string;\n+  answers_count: number;\n+  ips: string[];\n+  ttl_s: number;\n+  rrset_hash: string;\n+};\n+\n+function toHex(buf: ArrayBuffer): string {\n+  return [...new Uint8Array(buf)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n+}\n+\n+async function sha256Hex(input: string): Promise<string> {\n+  const hash = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(input));\n+  return toHex(hash);\n+}\n+\n+function normalizeName(name: string): string {\n+  return name.trim().toLowerCase().replace(/\\.$/, \"\");\n+}\n+\n+function mapType(type: number | string): string {\n+  if (typeof type === \"string\") return type.toUpperCase();\n+  if (type === 1) return \"A\";\n+  if (type === 28) return \"AAAA\";\n+  if (type === 5) return \"CNAME\";\n+  return String(type);\n+}\n+\n+async function queryOne(url: string, name: string, qtype: \"A\" | \"AAAA\", timeoutMs: number): Promise<UpstreamHit> {\n+  const started = Date.now();\n+  const ctrl = new AbortController();\n+  const timer = setTimeout(() => ctrl.abort(), timeoutMs);\n+  try {\n+    const u = new URL(url);\n+    u.searchParams.set(\"name\", name);\n+    u.searchParams.set(\"type\", qtype);\n+    const res = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" }, signal: ctrl.signal });\n+    if (!res.ok) {\n+      return { url, rtt_ms: Date.now() - started, status: `HTTP_${res.status}`, answers_count: 0, ips: [], ttl_s: 1, rrset_hash: await sha256Hex(`${qtype}|${name}|HTTP`) };\n+    }\n+    const json: any = await res.json();\n+    const status = Number(json?.Status ?? 2) === 0 ? \"NOERROR\" : Number(json?.Status ?? 2) === 3 ? \"NXDOMAIN\" : \"ERROR\";\n+    const answers = (Array.isArray(json?.Answer) ? json.Answer : [])\n+      .map((a: any) => ({ name: normalizeName(String(a?.name || \"\")), type: mapType(a?.type), data: String(a?.data || \"\"), ttl: Math.max(1, Number(a?.TTL || 60)) }))\n+      .filter((a: any) => a.name && a.type && a.data);\n+\n+    const byName = new Map<string, any[]>();\n+    for (const a of answers) {\n+      const prev = byName.get(a.name) || [];\n+      prev.push(a);\n+      byName.set(a.name, prev);\n+    }\n+\n+    let current = normalizeName(name);\n+    for (let i = 0; i < 10; i++) {\n+      const cn = (byName.get(current) || []).find((r) => r.type === \"CNAME\");\n+      if (!cn) break;\n+      current = normalizeName(cn.data);\n+    }\n+\n+    const finals = (byName.get(current) || []).filter((r) => r.type === qtype);\n+    const ips = [...new Set(finals.map((r) => r.data))].sort((a, b) => a.localeCompare(b));\n+    const ttl_s = finals.length ? Math.min(...finals.map((r) => r.ttl)) : status === \"NXDOMAIN\" ? 30 : 1;\n+    const rrset_hash = await sha256Hex(`${qtype}|${current}|${ips.join(\",\")}`);\n+\n+    return {\n+      url,\n+      rtt_ms: Date.now() - started,\n+      status,\n+      answers_count: ips.length,\n+      ips,\n+      ttl_s,\n+      rrset_hash\n+    };\n+  } catch {\n+    return { url, rtt_ms: Date.now() - started, status: \"TIMEOUT\", answers_count: 0, ips: [], ttl_s: 1, rrset_hash: await sha256Hex(`${qtype}|${name}|TIMEOUT`) };\n+  } finally {\n+    clearTimeout(timer);\n+  }\n+}\n+\n+function overlap(a: string[], b: string[]): boolean {\n+  const sb = new Set(b);\n+  return a.some((v) => sb.has(v));\n+}\n+\n+export default {\n+  async fetch(req: Request, env: Env): Promise<Response> {\n+    const url = new URL(req.url);\n+\n+    if (url.pathname === \"/v1/health\") {\n+      return Response.json({ ok: true, service: \"cf-worker-miner\" });\n+    }\n+\n+    if (url.pathname !== \"/resolve\") {\n+      return Response.json({ error: \"not_found\" }, { status: 404 });\n+    }\n+\n+    const name = normalizeName(url.searchParams.get(\"name\") || \"\");\n+    const qtype = (url.searchParams.get(\"type\") || \"A\").toUpperCase() === \"AAAA\" ? \"AAAA\" : \"A\";\n+    if (!name) return Response.json({ error: \"missing_name\" }, { status: 400 });\n+\n+    const upstreams = (env.UPSTREAMS || \"https://cloudflare-dns.com/dns-query,https://dns.google/resolve\")\n+      .split(\",\")\n+      .map((v) => v.trim())\n+      .filter(Boolean);\n+    const timeoutMs = Number(env.TIMEOUT_MS || \"2000\");\n+    const overlapRatio = Number(env.OVERLAP_RATIO || \"0.34\");\n+\n+    const hits = await Promise.all(upstreams.map((u) => queryOne(u, name, qtype, timeoutMs)));\n+    const ok = hits.filter((h) => h.status === \"NOERROR\" && h.ips.length > 0);\n+\n+    let confidence: \"high\" | \"medium\" | \"low\" = \"low\";\n+    let chosen = ok.sort((a, b) => a.rtt_ms - b.rtt_ms)[0] || hits.sort((a, b) => a.rtt_ms - b.rtt_ms)[0];\n+\n+    if (ok.length >= 2) {\n+      const byHash = new Map<string, UpstreamHit[]>();\n+      for (const h of ok) byHash.set(h.rrset_hash, [...(byHash.get(h.rrset_hash) || []), h]);\n+      const best = [...byHash.values()].sort((a, b) => b.length - a.length)[0] || [];\n+      if (best.length >= 2) {\n+        confidence = \"high\";\n+        chosen = best.sort((a, b) => a.rtt_ms - b.rtt_ms)[0];\n+      } else {\n+        const a = ok[0];\n+        const b = ok[1];\n+        const shared = overlap(a.ips, b.ips);\n+        const ratio = shared ? 1 : 0;\n+        if (shared || ratio >= overlapRatio) confidence = \"medium\";","path":"services/cf-worker-miner/src/index.ts","commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","original_commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`OVERLAP_RATIO` is effectively ignored: the code computes `ratio` as 0/1 based on `shared` and then checks `shared || ratio >= overlapRatio`, which reduces to just `shared`. If you want an overlap threshold, compute an actual overlap fraction (e.g., intersection / min(|A|,|B|)) and compare that to `overlapRatio`, or remove the env var to avoid a misleading config knob.\n```suggestion\n        const overlapCount = a.ips.filter((ip) => b.ips.includes(ip)).length;\n        const minCount = Math.min(a.ips.length, b.ips.length);\n        const ratio = minCount > 0 ? overlapCount / minCount : 0;\n        if (ratio >= overlapRatio) confidence = \"medium\";\n```","created_at":"2026-02-18T10:46:30Z","updated_at":"2026-02-18T10:46:34Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628583","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628583"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628583"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628583/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":136,"original_start_line":136,"start_side":"RIGHT","line":138,"original_line":138,"side":"RIGHT","author_association":"NONE","original_position":138,"position":138,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628630","pull_request_review_id":3819136936,"id":2821628630,"node_id":"PRRC_kwDORKbd9s6oLqLW","diff_hunk":"@@ -0,0 +1,175 @@\n+type Env = {\n+  UPSTREAMS?: string;\n+  TIMEOUT_MS?: string;\n+  OVERLAP_RATIO?: string;\n+  RECEIPT_ENDPOINT?: string;\n+};\n+\n+type UpstreamHit = {\n+  url: string;\n+  rtt_ms: number;\n+  status: string;\n+  answers_count: number;\n+  ips: string[];\n+  ttl_s: number;\n+  rrset_hash: string;\n+};\n+\n+function toHex(buf: ArrayBuffer): string {\n+  return [...new Uint8Array(buf)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n+}\n+\n+async function sha256Hex(input: string): Promise<string> {\n+  const hash = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(input));\n+  return toHex(hash);\n+}\n+\n+function normalizeName(name: string): string {\n+  return name.trim().toLowerCase().replace(/\\.$/, \"\");\n+}\n+\n+function mapType(type: number | string): string {\n+  if (typeof type === \"string\") return type.toUpperCase();\n+  if (type === 1) return \"A\";\n+  if (type === 28) return \"AAAA\";\n+  if (type === 5) return \"CNAME\";\n+  return String(type);\n+}\n+\n+async function queryOne(url: string, name: string, qtype: \"A\" | \"AAAA\", timeoutMs: number): Promise<UpstreamHit> {\n+  const started = Date.now();\n+  const ctrl = new AbortController();\n+  const timer = setTimeout(() => ctrl.abort(), timeoutMs);\n+  try {\n+    const u = new URL(url);\n+    u.searchParams.set(\"name\", name);\n+    u.searchParams.set(\"type\", qtype);\n+    const res = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" }, signal: ctrl.signal });\n+    if (!res.ok) {\n+      return { url, rtt_ms: Date.now() - started, status: `HTTP_${res.status}`, answers_count: 0, ips: [], ttl_s: 1, rrset_hash: await sha256Hex(`${qtype}|${name}|HTTP`) };\n+    }\n+    const json: any = await res.json();\n+    const status = Number(json?.Status ?? 2) === 0 ? \"NOERROR\" : Number(json?.Status ?? 2) === 3 ? \"NXDOMAIN\" : \"ERROR\";\n+    const answers = (Array.isArray(json?.Answer) ? json.Answer : [])\n+      .map((a: any) => ({ name: normalizeName(String(a?.name || \"\")), type: mapType(a?.type), data: String(a?.data || \"\"), ttl: Math.max(1, Number(a?.TTL || 60)) }))\n+      .filter((a: any) => a.name && a.type && a.data);\n+\n+    const byName = new Map<string, any[]>();\n+    for (const a of answers) {\n+      const prev = byName.get(a.name) || [];\n+      prev.push(a);\n+      byName.set(a.name, prev);\n+    }\n+\n+    let current = normalizeName(name);\n+    for (let i = 0; i < 10; i++) {\n+      const cn = (byName.get(current) || []).find((r) => r.type === \"CNAME\");\n+      if (!cn) break;\n+      current = normalizeName(cn.data);\n+    }\n+\n+    const finals = (byName.get(current) || []).filter((r) => r.type === qtype);\n+    const ips = [...new Set(finals.map((r) => r.data))].sort((a, b) => a.localeCompare(b));\n+    const ttl_s = finals.length ? Math.min(...finals.map((r) => r.ttl)) : status === \"NXDOMAIN\" ? 30 : 1;\n+    const rrset_hash = await sha256Hex(`${qtype}|${current}|${ips.join(\",\")}`);\n+\n+    return {\n+      url,\n+      rtt_ms: Date.now() - started,\n+      status,\n+      answers_count: ips.length,\n+      ips,\n+      ttl_s,\n+      rrset_hash\n+    };\n+  } catch {\n+    return { url, rtt_ms: Date.now() - started, status: \"TIMEOUT\", answers_count: 0, ips: [], ttl_s: 1, rrset_hash: await sha256Hex(`${qtype}|${name}|TIMEOUT`) };\n+  } finally {\n+    clearTimeout(timer);\n+  }\n+}\n+\n+function overlap(a: string[], b: string[]): boolean {\n+  const sb = new Set(b);\n+  return a.some((v) => sb.has(v));\n+}\n+\n+export default {\n+  async fetch(req: Request, env: Env): Promise<Response> {\n+    const url = new URL(req.url);\n+\n+    if (url.pathname === \"/v1/health\") {\n+      return Response.json({ ok: true, service: \"cf-worker-miner\" });\n+    }\n+\n+    if (url.pathname !== \"/resolve\") {\n+      return Response.json({ error: \"not_found\" }, { status: 404 });\n+    }\n+\n+    const name = normalizeName(url.searchParams.get(\"name\") || \"\");\n+    const qtype = (url.searchParams.get(\"type\") || \"A\").toUpperCase() === \"AAAA\" ? \"AAAA\" : \"A\";\n+    if (!name) return Response.json({ error: \"missing_name\" }, { status: 400 });\n+\n+    const upstreams = (env.UPSTREAMS || \"https://cloudflare-dns.com/dns-query,https://dns.google/resolve\")\n+      .split(\",\")\n+      .map((v) => v.trim())\n+      .filter(Boolean);\n+    const timeoutMs = Number(env.TIMEOUT_MS || \"2000\");\n+    const overlapRatio = Number(env.OVERLAP_RATIO || \"0.34\");\n+\n+    const hits = await Promise.all(upstreams.map((u) => queryOne(u, name, qtype, timeoutMs)));\n+    const ok = hits.filter((h) => h.status === \"NOERROR\" && h.ips.length > 0);\n+\n+    let confidence: \"high\" | \"medium\" | \"low\" = \"low\";\n+    let chosen = ok.sort((a, b) => a.rtt_ms - b.rtt_ms)[0] || hits.sort((a, b) => a.rtt_ms - b.rtt_ms)[0];\n+\n+    if (ok.length >= 2) {\n+      const byHash = new Map<string, UpstreamHit[]>();\n+      for (const h of ok) byHash.set(h.rrset_hash, [...(byHash.get(h.rrset_hash) || []), h]);\n+      const best = [...byHash.values()].sort((a, b) => b.length - a.length)[0] || [];\n+      if (best.length >= 2) {\n+        confidence = \"high\";\n+        chosen = best.sort((a, b) => a.rtt_ms - b.rtt_ms)[0];\n+      } else {\n+        const a = ok[0];\n+        const b = ok[1];\n+        const shared = overlap(a.ips, b.ips);\n+        const ratio = shared ? 1 : 0;\n+        if (shared || ratio >= overlapRatio) confidence = \"medium\";\n+      }\n+    }\n+\n+    const ttlBase = chosen?.ttl_s || 30;\n+    const ttlCap = confidence === \"high\" ? 300 : confidence === \"medium\" ? 120 : 30;\n+    const ttl_s = Math.max(1, Math.min(ttlBase, ttlCap));\n+\n+    const response = {\n+      name,\n+      type: qtype,\n+      answers: chosen?.ips || [],\n+      ttl_s,\n+      rrset_hash: chosen?.rrset_hash || \"\",\n+      confidence,\n+      upstreams_used: hits.map((h) => ({\n+        url: h.url,\n+        rtt_ms: h.rtt_ms,\n+        status: h.status,\n+        answers_count: h.answers_count\n+      })),\n+      chosen_upstream: chosen ? { url: chosen.url, rtt_ms: chosen.rtt_ms } : null\n+    };","path":"services/cf-worker-miner/src/index.ts","commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","original_commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"When all upstreams fail (timeouts/HTTP errors), this handler still returns 200 with an empty `answers` array and no top-level `status`/error indicator. Consider returning a non-2xx status (e.g., 502) or including a top-level `status` field derived from `chosen.status` so callers can distinguish upstream failure from a valid empty result.","created_at":"2026-02-18T10:46:31Z","updated_at":"2026-02-18T10:46:34Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628630","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628630"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628630"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628630/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":146,"original_start_line":146,"start_side":"RIGHT","line":160,"original_line":160,"side":"RIGHT","author_association":"NONE","original_position":160,"position":160,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628652","pull_request_review_id":3819136936,"id":2821628652,"node_id":"PRRC_kwDORKbd9s6oLqLs","diff_hunk":"","path":"gateway/src/adapters/recursive.ts","commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","original_commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The on-disk cache format changed (new required fields like `sourceStatus`, `confidence`, `rrsetHash`, `upstreamsUsed`, `chosenUpstream`) but `CacheFile.version` is still `1` and `loadCache()` blindly loads existing entries. An older `gateway/.cache/rrset.json` will deserialize with missing fields and later code will throw (e.g., `out.chosenUpstream.url`). Bump the cache version and treat older versions as empty/migrated, or add a migration/defaulting step when reading entries.","created_at":"2026-02-18T10:46:31Z","updated_at":"2026-02-18T10:46:34Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628652","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628652"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628652"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628652/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":58,"original_start_line":58,"start_side":"RIGHT","line":61,"original_line":61,"side":"RIGHT","author_association":"NONE","original_position":1,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628666","pull_request_review_id":3819136936,"id":2821628666,"node_id":"PRRC_kwDORKbd9s6oLqL6","diff_hunk":"@@ -68,46 +401,60 @@ export function createRecursiveAdapter(cfg: RecursiveAdapterConfig): RecursiveAd\n     const maxEntries = Math.max(1, Number(cfg.cacheMaxEntries || 50000));\n     if (cache.size <= maxEntries) return;\n     const items = [...cache.entries()].sort((a, b) => a[1].fetchedAt - b[1].fetchedAt);\n-    for (let i = 0; i < items.length - maxEntries; i++) {\n-      cache.delete(items[i][0]);\n-    }\n+    for (let i = 0; i < items.length - maxEntries; i++) cache.delete(items[i][0]);\n   }\n \n-  async function refresh(qname: string, qtype: string, cacheKey: string): Promise<RecursiveResolveResult> {\n-    const rotated = urls.slice(rr % urls.length).concat(urls.slice(0, rr % urls.length));\n-    rr++;\n-    let lastErr: unknown;\n-    for (const upstream of rotated) {\n-      try {\n-        const r = await queryDohJson(fetchImpl, upstream, qname, qtype, timeoutMs);\n-        const now = nowS();\n-        const entry: CacheEntry = {\n-          qname,\n-          qtype,\n-          answers: r.answers,\n-          ttlS: r.ttlS,\n-          fetchedAt: now,\n-          expiresAt: now + r.ttlS,\n-          staleUntil: now + r.ttlS + Math.max(0, Number(cfg.staleMaxS || 1800)),\n-          upstream\n-        };\n-        cache.set(cacheKey, entry);\n-        evictIfNeeded();\n-        persist();\n-        return { name: qname, type: qtype, answers: r.answers, ttlS: r.ttlS, source: \"upstream\", upstream };\n-      } catch (e) {\n-        lastErr = e;\n-      }\n-    }\n-    throw lastErr || new Error(\"UPSTREAM_FAILED\");\n+  async function refresh(qname: string, qtype: \"A\" | \"AAAA\", cacheKey: string): Promise<RecursiveResolveResult> {\n+    const upstreams = await queryUpstreams(fetchImpl, urls, qname, qtype, timeoutMs, maxConcurrency);\n+    const chosen = selectBest(upstreams, quorumMin, overlapThreshold, ttlCapS);\n+\n+    const upstreamsUsed: UpstreamAudit[] = upstreams.map((u) => ({\n+      url: u.url,\n+      rttMs: u.rttMs,\n+      status: u.status,\n+      answersCount: u.answersCount\n+    }));\n+\n+    const now = nowS();\n+    const entry: CacheEntry = {\n+      qname,\n+      qtype,\n+      answers: chosen.status === \"NOERROR\" ? chosen.chosen.answers : [],\n+      ttlS: chosen.ttlS,\n+      fetchedAt: now,\n+      expiresAt: now + chosen.ttlS,\n+      staleUntil: now + chosen.ttlS + Math.max(0, Number(cfg.staleMaxS || 1800)),\n+      sourceStatus: chosen.status,\n+      confidence: chosen.confidence,\n+      rrsetHash: chosen.chosen.rrsetHash,\n+      upstreamsUsed,\n+      chosenUpstream: { url: chosen.chosen.url, rttMs: chosen.chosen.rttMs }\n+    };\n+\n+    cache.set(cacheKey, entry);\n+    evictIfNeeded();\n+    persist();\n+\n+    return {\n+      name: qname,\n+      type: qtype,\n+      answers: entry.answers,\n+      ttlS: entry.ttlS,\n+      source: \"upstream\",\n+      status: entry.sourceStatus,\n+      confidence: entry.confidence,\n+      upstreamsUsed: entry.upstreamsUsed,\n+      chosenUpstream: entry.chosenUpstream,\n+      rrsetHash: entry.rrsetHash\n+    };\n   }\n \n   async function resolveRecursive(name: string, qtype = \"A\"): Promise<RecursiveResolveResult> {\n     const qname = normalizeNameForHash(name);\n-    const q = qtype.toUpperCase();\n+    const q = qtype.toUpperCase() === \"AAAA\" ? \"AAAA\" : \"A\";","path":"gateway/src/adapters/recursive.ts","commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","original_commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`resolveRecursive()` now coerces any qtype other than `AAAA` to `A` (`const q = ... ? \"AAAA\" : \"A\"`). Previously the adapter accepted arbitrary qtypes (e.g., TXT) via `queryDohJson`, and callers like `resolve_cli.ts` allow `--qtype` to be set to anything. Either (a) validate and reject unsupported qtypes with a clear error, or (b) extend the quorum logic to support additional record types.\n```suggestion\n    const upperQtype = qtype.toUpperCase();\n    if (upperQtype !== \"A\" && upperQtype !== \"AAAA\") {\n      throw new Error(`Unsupported qtype \"${qtype}\". Only A and AAAA are supported by the recursive adapter.`);\n    }\n    const q = upperQtype as \"A\" | \"AAAA\";\n```","created_at":"2026-02-18T10:46:32Z","updated_at":"2026-02-18T10:46:34Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628666","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628666"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628666"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628666/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":454,"original_line":454,"side":"RIGHT","author_association":"NONE","original_position":481,"position":481,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628694","pull_request_review_id":3819136936,"id":2821628694,"node_id":"PRRC_kwDORKbd9s6oLqMW","diff_hunk":"@@ -1,35 +1,45 @@\n-# Resolver (Name Gateway MVP)\n+# Gateway (MVP)\n \n-This is the MVP name gateway service.\n+## Resolver behavior\n+- `.dns` names are resolved through **PKDNS** first (on-chain canonical/hash verification path).\n+- Non-`.dns` ICANN names use **recursive DoH** with local TTL cache.\n+- ICANN answers are never written into canonical consensus; they are local gateway cache state only.\n \n-## Endpoints\n-- `GET /resolve?name=<domain>`\n-- `GET /healthz`\n+## Recursive quorum (ICANN)\n+- Upstreams are queried in parallel (default: Cloudflare + Google).\n+- Confidence levels:\n+  - `high`: normalized RRset hash quorum match.\n+  - `medium`: upstream sets overlap (CDN rotation tolerance).\n+  - `low`: only one usable upstream or disagreement.\n+- TTL policy:\n+  - base TTL = minimum upstream TTL for chosen RRset.\n+  - caps: `high -> TTL_CAP_S`, `medium -> min(TTL_CAP_S,120)`, `low -> min(TTL_CAP_S,30)`.\n+  - NXDOMAIN TTL is capped to 30 seconds.\n \n-Response format:\n-```json\n-{\n-  \"name\": \"example.com\",\n-  \"network\": \"icann\",\n-  \"records\": [{ \"type\": \"A\", \"value\": \"203.0.113.10\", \"ttl\": 60 }],\n-  \"metadata\": { \"source\": \"doh\", \"cache\": \"miss\" }\n-}\n-```\n+## Cache behavior\n+- Keyed by `name:qtype`.\n+- Supports stale-if-error (`STALE_MAX_S`) and prefetch (`PREFETCH_FRACTION`).\n+- Cache file defaults to `gateway/.cache/rrset.json`.\n \n-## Run\n-```bash\n-cd /Users/root1/dev/web3-repos/DECENTRALIZED-DNS-/resolver\n-npm install\n-npm run build\n-PORT=8054 npm start\n-```\n+## API\n+- `GET /v1/resolve?name=<domain>&type=A|AAAA`\n \n-## Tests\n-```bash\n-npm test\n-```\n+Response keys:\n+- `name`, `type`, `answers`, `ttl_s`\n+- `source` (`recursive`)\n+- `confidence`\n+- `upstreams_used[]`, `chosen_upstream`\n+- `cache` (`hit`, `stale_used?`)\n+- `status`, `rrset_hash`\n \n-## Env\n-- `UPSTREAM_DOH_URL` (default: Cloudflare DoH)\n-- `REQUEST_TIMEOUT_MS` (default: 2000)\n-- `PORT` (default: 8054)\n+## Env (recursive)\n+- `RECURSIVE_UPSTREAMS` (default `https://cloudflare-dns.com/dns-query,https://dns.google/dns-query`)\n+- `RECURSIVE_QUORUM_MIN` (default `2`)\n+- `RECURSIVE_TIMEOUT_MS` (default `2000`)","path":"gateway/README.md","commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","original_commit_id":"337bd3999268089a1a124021ab1ea9b63414ee45","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Docs say `RECURSIVE_TIMEOUT_MS` defaults to `2000`, but in `server.ts` it defaults to `REQUEST_TIMEOUT_MS`, which itself defaults to `5000`. Please update the README default (or change the code default) so operators don't misconfigure timeouts based on incorrect docs.\n```suggestion\n- `RECURSIVE_TIMEOUT_MS` (default `5000`)\n```","created_at":"2026-02-18T10:46:32Z","updated_at":"2026-02-18T10:46:32Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628694","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628694"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/68#discussion_r2821628694"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/68"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821628694/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":38,"original_line":38,"side":"RIGHT","author_association":"NONE","original_position":67,"position":67,"subject_type":"line"}]