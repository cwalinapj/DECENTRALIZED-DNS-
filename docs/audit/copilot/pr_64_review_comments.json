[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278838","pull_request_review_id":3818737933,"id":2821278838,"node_id":"PRRC_kwDORKbd9s6oKUx2","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`unique_name_hashes` and `unique_colos` are fully user-provided inputs. Because `award_rep` does not verify these counts against `receipts_root` (or any on-chain data), a miner can bypass the diversity gate and inflate bonuses by submitting arbitrary large values. If diversity is meant to be enforced on-chain, the instruction needs a verifiable commitment/proof scheme (e.g., include/verifiably derive the counts from data committed by `receipts_root`, or require proofs for at least the minimum unique items).","created_at":"2026-02-18T09:30:43Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278838","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278838"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278838"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278838/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":128,"original_start_line":119,"start_side":"RIGHT","line":132,"original_line":123,"side":"RIGHT","author_association":"NONE","original_position":123,"position":132,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278882","pull_request_review_id":3818737933,"id":2821278882,"node_id":"PRRC_kwDORKbd9s6oKUyi","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The “duplicate root” guard only compares `receipts_root` with `rep.last_receipts_root`, which only prevents submitting the same root twice in a row. Submitting root A, then root B, then root A again will not be rejected. If the intent is to prevent replaying any previously used root, you’ll need to persist a per-root marker (e.g., a PDA keyed by `[\"rep_root\", miner, epoch_id, receipts_root]` or similar) or store a bounded history.","created_at":"2026-02-18T09:30:43Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278882","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278882"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278882"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278882/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":148,"original_start_line":139,"start_side":"RIGHT","line":150,"original_line":141,"side":"RIGHT","author_association":"NONE","original_position":141,"position":150,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278902","pull_request_review_id":3818737933,"id":2821278902,"node_id":"PRRC_kwDORKbd9s6oKUy2","diff_hunk":"@@ -0,0 +1,441 @@\n+use anchor_lang::prelude::*;\n+\n+declare_id!(\"DWV9QLGWmsrteqpbKb55JmHTsdtqgLukvnzQgEq36pQ9\");\n+\n+const BONUS_DENOM: u128 = 10_000;\n+const MAX_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_rep {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_rep_config(\n+        ctx: Context<InitRepConfig>,\n+        epoch_len_slots: u64,\n+        daily_rep_cap_per_miner: u64,\n+        min_bond_lamports: u64,\n+        min_unique_name_hashes: u32,\n+        min_unique_colos: u16,\n+        rep_per_valid_aggregate: u64,\n+        rep_decay_per_epoch: u64,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, RepError::InvalidConfig);\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.daily_rep_cap_per_miner = daily_rep_cap_per_miner;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.min_unique_name_hashes = min_unique_name_hashes;\n+        cfg.min_unique_colos = min_unique_colos;\n+        cfg.rep_per_valid_aggregate = rep_per_valid_aggregate;\n+        cfg.rep_decay_per_epoch = rep_decay_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_rep_bond(ctx: Context<DepositRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        bond.last_deposit_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_rep_bond(ctx: Context<WithdrawRepBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, RepError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_deposit_slot.saturating_add(cfg.cooldown_slots),\n+            RepError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, RepError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            RepError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(RepError::MathOverflow))?;\n+        Ok(())\n+    }\n+\n+    pub fn award_rep(\n+        ctx: Context<AwardRep>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        _receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        let cfg = &ctx.accounts.config;\n+        require!(cfg.enabled, RepError::Disabled);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            RepError::InsufficientBond\n+        );\n+        require!(\n+            unique_name_hashes >= cfg.min_unique_name_hashes,\n+            RepError::DiversityTooLow\n+        );\n+        require!(unique_colos >= cfg.min_unique_colos, RepError::DiversityTooLow);\n+\n+        let clock = Clock::get()?;\n+        let now_slot = clock.slot;\n+        let now_day = day_id(clock.unix_timestamp)?;\n+        let expected_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(expected_epoch == epoch_id, RepError::BadEpoch);\n+\n+        let rep = &mut ctx.accounts.rep;\n+        if rep.miner == Pubkey::default() {\n+            rep.miner = ctx.accounts.miner.key();\n+            rep.rep_today_day_id = now_day;\n+            rep.bump = ctx.bumps.rep;\n+        }\n+        require!(rep.miner == ctx.accounts.miner.key(), RepError::InvalidMiner);\n+\n+        if rep.last_receipts_root == receipts_root {\n+            return err!(RepError::DuplicateRoot);\n+        }\n+        if rep.last_claim_slot > 0 {\n+            require!(\n+                now_slot >= rep.last_claim_slot.saturating_add(cfg.cooldown_slots),\n+                RepError::CooldownNotMet\n+            );\n+        }\n+\n+        if rep.rep_today_day_id != now_day {\n+            rep.rep_today_day_id = now_day;\n+            rep.rep_today = 0;\n+        }\n+\n+        if cfg.rep_decay_per_epoch > 0 && rep.last_epoch_seen > 0 && epoch_id > rep.last_epoch_seen {\n+            let elapsed = epoch_id.saturating_sub(rep.last_epoch_seen);\n+            let decay = cfg\n+                .rep_decay_per_epoch\n+                .saturating_mul(elapsed)\n+                .min(rep.rep_total);\n+            rep.rep_total = rep.rep_total.saturating_sub(decay);\n+        }\n+\n+        let bonus_bps = compute_diversity_bonus_bps(cfg, unique_name_hashes, unique_colos);\n+        let raw_award = ((cfg.rep_per_valid_aggregate as u128)\n+            .checked_mul((BONUS_DENOM + bonus_bps as u128) as u128)\n+            .ok_or(error!(RepError::MathOverflow))?\n+            / BONUS_DENOM) as u64;\n+\n+        let remaining_today = cfg.daily_rep_cap_per_miner.saturating_sub(rep.rep_today);\n+        let award = raw_award.min(remaining_today);\n+        require!(award > 0, RepError::DailyCapReached);\n+\n+        rep.rep_total = rep.rep_total.saturating_add(award);\n+        rep.rep_today = rep.rep_today.saturating_add(award);\n+        rep.last_epoch_seen = epoch_id;\n+        rep.last_claim_slot = now_slot;\n+        rep.last_receipts_root = receipts_root;\n+\n+        emit!(RepAwarded {\n+            miner: ctx.accounts.miner.key(),\n+            epoch_id,\n+            awarded: award,\n+            bonus_bps,\n+            rep_total: rep.rep_total,\n+            rep_today: rep.rep_today,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn slash_rep_bond(\n+        ctx: Context<SlashRepBond>,\n+        slash_lamports: u64,\n+        strike_inc: u32,\n+    ) -> Result<()> {\n+        require!(slash_lamports > 0 || strike_inc > 0, RepError::InvalidAmount);\n+\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        if slash_lamports > 0 {\n+            require!(bond_view.bond_lamports >= slash_lamports, RepError::InsufficientBond);\n+\n+            let rent = Rent::get()?;\n+            let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+            require!(\n+                current.saturating_sub(slash_lamports) >= min_lamports,\n+                RepError::BondRentViolation\n+            );\n+\n+            **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= slash_lamports;\n+            **ctx.accounts.slash_destination.to_account_info().try_borrow_mut_lamports()? += slash_lamports;\n+            let bond = &mut ctx.accounts.bond;\n+            bond.bond_lamports = bond\n+                .bond_lamports\n+                .checked_sub(slash_lamports)\n+                .ok_or(error!(RepError::MathOverflow))?;\n+        }\n+\n+        if strike_inc > 0 {\n+            let rep = &mut ctx.accounts.rep;\n+            rep.strikes = rep.strikes.saturating_add(strike_inc);\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitRepConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + RepConfig::SIZE,\n+        seeds = [b\"rep_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct DepositRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerBond::SIZE,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct WithdrawRepBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct AwardRep<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(seeds = [b\"rep_config\"], bump = config.bump)]\n+    pub config: Account<'info, RepConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ RepError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerRep::SIZE,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub rep: Account<'info, MinerRep>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SlashRepBond<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        seeds = [b\"rep_config\"],\n+        bump = config.bump,\n+        has_one = authority @ RepError::Unauthorized,\n+    )]\n+    pub config: Account<'info, RepConfig>,\n+    /// CHECK: any lamports destination\n+    #[account(mut)]\n+    pub slash_destination: UncheckedAccount<'info>,\n+    /// CHECK: used only as PDA seed target for bond/rep and does not require owner/type checks.\n+    #[account(mut)]\n+    pub miner: UncheckedAccount<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"rep_bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        mut,\n+        seeds = [b\"miner_rep\", miner.key().as_ref()],\n+        bump = rep.bump,\n+    )]\n+    pub rep: Account<'info, MinerRep>,\n+}\n+\n+#[account]\n+pub struct RepConfig {\n+    pub authority: Pubkey,\n+    pub epoch_len_slots: u64,\n+    pub daily_rep_cap_per_miner: u64,\n+    pub min_bond_lamports: u64,\n+    pub min_unique_name_hashes: u32,\n+    pub min_unique_colos: u16,\n+    pub rep_per_valid_aggregate: u64,\n+    pub rep_decay_per_epoch: u64,\n+    pub cooldown_slots: u64,\n+    pub enabled: bool,\n+    pub bump: u8,\n+}\n+\n+impl RepConfig {\n+    pub const SIZE: usize = 32 + 8 + 8 + 8 + 4 + 2 + 8 + 8 + 8 + 1 + 1;\n+}\n+\n+#[account]\n+pub struct MinerBond {\n+    pub miner: Pubkey,\n+    pub bond_lamports: u64,\n+    pub last_deposit_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl MinerBond {\n+    pub const SIZE: usize = 32 + 8 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct MinerRep {\n+    pub miner: Pubkey,\n+    pub rep_total: u64,\n+    pub rep_today: u64,\n+    pub rep_today_day_id: u64,\n+    pub last_epoch_seen: u64,\n+    pub strikes: u32,\n+    pub last_claim_slot: u64,\n+    pub last_receipts_root: [u8; 32],\n+    pub bump: u8,\n+}\n+\n+impl MinerRep {\n+    pub const SIZE: usize = 32 + 8 + 8 + 8 + 8 + 4 + 8 + 32 + 1;\n+}\n+\n+#[event]\n+pub struct RepAwarded {\n+    pub miner: Pubkey,\n+    pub epoch_id: u64,\n+    pub awarded: u64,\n+    pub bonus_bps: u16,\n+    pub rep_total: u64,\n+    pub rep_today: u64,\n+}\n+\n+#[error_code]\n+pub enum RepError {\n+    #[msg(\"Invalid config\")]\n+    InvalidConfig,\n+    #[msg(\"Unauthorized\")]\n+    Unauthorized,\n+    #[msg(\"Invalid amount\")]\n+    InvalidAmount,\n+    #[msg(\"Math overflow\")]\n+    MathOverflow,\n+    #[msg(\"Disabled\")]\n+    Disabled,\n+    #[msg(\"Invalid miner\")]\n+    InvalidMiner,\n+    #[msg(\"Insufficient bond\")]\n+    InsufficientBond,\n+    #[msg(\"Cooldown not met\")]\n+    CooldownNotMet,\n+    #[msg(\"Bond rent-exemption violation\")]\n+    BondRentViolation,\n+    #[msg(\"Diversity too low\")]\n+    DiversityTooLow,\n+    #[msg(\"Daily cap reached\")]\n+    DailyCapReached,\n+    #[msg(\"Duplicate receipts root\")]\n+    DuplicateRoot,\n+    #[msg(\"Bad epoch\")]\n+    BadEpoch,\n+}\n+\n+fn day_id(unix_ts: i64) -> Result<u64> {\n+    require!(unix_ts >= 0, RepError::InvalidConfig);\n+    Ok((unix_ts as u64) / 86_400)\n+}\n+\n+fn compute_diversity_bonus_bps(cfg: &RepConfig, names: u32, colos: u16) -> u16 {\n+    let name_excess = names.saturating_sub(cfg.min_unique_name_hashes);\n+    let colo_excess = colos.saturating_sub(cfg.min_unique_colos);\n+    let name_bonus = name_excess.saturating_mul(20); // 0.2% per extra unique name\n+    let colo_bonus = (colo_excess as u32).saturating_mul(100); // 1% per extra colo\n+    (name_bonus.saturating_add(colo_bonus) as u16).min(MAX_BONUS_BPS)","path":"solana/programs/ddns_rep/src/lib.rs","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`compute_diversity_bonus_bps` computes bonuses in `u32` but then casts the sum to `u16` before applying the `MAX_BONUS_BPS` cap. If the `u32` sum exceeds `u16::MAX`, the cast truncates and can yield an incorrect (wrapped) bonus. Clamp to `MAX_BONUS_BPS` in `u32` before converting to `u16`.\n```suggestion\n    let total_bonus_bps_u32 = name_bonus.saturating_add(colo_bonus).min(MAX_BONUS_BPS as u32);\n    total_bonus_bps_u32 as u16\n```","created_at":"2026-02-18T09:30:44Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278902","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278902"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278902"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278902/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":484,"original_line":440,"side":"RIGHT","author_association":"NONE","original_position":440,"position":484,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278944","pull_request_review_id":3818737933,"id":2821278944,"node_id":"PRRC_kwDORKbd9s6oKUzg","diff_hunk":"@@ -0,0 +1,215 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import crypto from \"node:crypto\";\n+import http from \"node:http\";\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { PublicKey, Keypair, SystemProgram } from \"@solana/web3.js\";\n+\n+type DnsAnswer = { name: string; type: number; TTL: number; data: string };\n+type ReceiptLike = { name: string; name_hash: string; rrset_hash: string; colo?: string };\n+\n+function loadKeypair(filePath: string): Keypair {\n+  return Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs.readFileSync(filePath, \"utf8\"))));\n+}\n+\n+function sha256(buf: Buffer): Buffer {\n+  return crypto.createHash(\"sha256\").update(buf).digest();\n+}\n+\n+function nameHash(name: string): Buffer {\n+  return sha256(Buffer.from(name.trim().toLowerCase(), \"utf8\"));\n+}\n+\n+function rrsetHash(answers: DnsAnswer[]): Buffer {\n+  const canon = answers\n+    .map((a) => `${a.name.toLowerCase()}|${a.type}|${a.data}|${a.TTL}`)\n+    .sort()\n+    .join(\"\\n\");\n+  return sha256(Buffer.from(canon, \"utf8\"));\n+}\n+\n+function merkleRoot(leaves: Buffer[]): Buffer {\n+  if (leaves.length === 0) return Buffer.alloc(32, 0);\n+  let level = leaves.map((l) => sha256(l));\n+  while (level.length > 1) {\n+    const next: Buffer[] = [];\n+    for (let i = 0; i < level.length; i += 2) {\n+      const a = level[i];\n+      const b = i + 1 < level.length ? level[i + 1] : a;\n+      next.push(sha256(Buffer.concat([a, b])));\n+    }\n+    level = next;\n+  }\n+  return level[0];\n+}\n+\n+async function dohResolve(upstream: string, name: string, qtype: string): Promise<DnsAnswer[]> {\n+  const u = new URL(upstream);\n+  u.searchParams.set(\"name\", name);\n+  u.searchParams.set(\"type\", qtype);\n+  const r = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" } });\n+  if (!r.ok) throw new Error(`upstream_${r.status}`);\n+  const j: any = await r.json();\n+  return Array.isArray(j?.Answer) ? j.Answer : [];\n+}\n+\n+function readProgramIdFromAnchorToml(rpcUrl: string): string | null {\n+  const p = path.resolve(process.cwd(), \"../../solana/Anchor.toml\");\n+  if (!fs.existsSync(p)) return null;\n+  const content = fs.readFileSync(p, \"utf8\");\n+  const section = /localhost|127\\.0\\.0\\.1/.test(rpcUrl) ? \"programs.localnet\" : \"programs.devnet\";\n+  const re = new RegExp(`\\\\[${section}\\\\][^\\\\[]*?ddns_rep\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"`, \"s\");\n+  const m = content.match(re);\n+  return m ? m[1] : null;\n+}\n+\n+function loadRepIdl() {\n+  const p = path.resolve(process.cwd(), \"../../solana/target/idl/ddns_rep.json\");\n+  if (!fs.existsSync(p)) throw new Error(`missing idl at ${p}; run anchor build in solana/ first`);\n+  return JSON.parse(fs.readFileSync(p, \"utf8\"));\n+}\n+\n+function leavesFromReceipts(receipts: ReceiptLike[]): { leaves: Buffer[]; uniqueNames: number; uniqueColos: number } {\n+  const leaves = receipts.map((r) => {\n+    const nh = /^[0-9a-fA-F]{64}$/.test(r.name_hash)\n+      ? Buffer.from(r.name_hash, \"hex\")\n+      : nameHash(r.name);\n+    const dh = /^[0-9a-fA-F]{64}$/.test(r.rrset_hash)\n+      ? Buffer.from(r.rrset_hash, \"hex\")\n+      : sha256(Buffer.from(r.rrset_hash, \"utf8\"));\n+    const colo = sha256(Buffer.from(r.colo || \"unknown\", \"utf8\"));\n+    return Buffer.concat([nh, dh, colo]);\n+  });\n+  const uniqueNames = new Set(receipts.map((r) => r.name_hash || r.name.toLowerCase())).size;\n+  const uniqueColos = new Set(receipts.map((r) => r.colo || \"unknown\")).size;\n+  return { leaves, uniqueNames, uniqueColos };\n+}\n+\n+async function submitAward(\n+  program: any,\n+  wallet: Keypair,\n+  epochId: number,\n+  leaves: Buffer[],\n+  uniqueNames: number,\n+  uniqueColos: number,\n+) {\n+  const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+  const [bondPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_bond\"), wallet.publicKey.toBuffer()], program.programId);\n+  const [repPda] = PublicKey.findProgramAddressSync([Buffer.from(\"miner_rep\"), wallet.publicKey.toBuffer()], program.programId);\n+\n+  const root = merkleRoot(leaves);\n+  const sig = await program.methods\n+    .awardRep(new anchor.BN(epochId), [...root], leaves.length, uniqueNames, uniqueColos)\n+    .accounts({\n+      miner: wallet.publicKey,\n+      config: configPda,\n+      bond: bondPda,\n+      rep: repPda,\n+      systemProgram: SystemProgram.programId,\n+    })\n+    .signers([wallet])\n+    .rpc();\n+\n+  return { sig, root: root.toString(\"hex\"), repPda: repPda.toBase58() };\n+}\n+\n+async function main() {\n+  const RPC_URL = process.env.SOLANA_RPC_URL || process.env.ANCHOR_PROVIDER_URL || \"https://api.devnet.solana.com\";\n+  const WALLET = process.env.MINER_WALLET || process.env.ANCHOR_WALLET || path.join(process.env.HOME || \".\", \".config/solana/id.json\");\n+  const PROGRAM_ID = process.env.DDNS_REP_PROGRAM_ID || readProgramIdFromAnchorToml(RPC_URL);\n+  const NAMES = (process.env.MINER_NAMES || \"example.com,netflix.com,cloudflare.com\")\n+    .split(\",\")\n+    .map((s) => s.trim())\n+    .filter(Boolean);\n+  const QTYPE = process.env.MINER_QTYPE || \"A\";\n+  const COLO = process.env.MINER_COLO || \"local-node\";\n+  const DOH = (process.env.RECURSIVE_UPSTREAMS || \"https://cloudflare-dns.com/dns-query,https://dns.google/resolve\")\n+    .split(\",\")\n+    .map((s) => s.trim())\n+    .filter(Boolean);\n+  const SERVE = process.env.MINER_HTTP === \"1\";\n+  const PORT = Number(process.env.MINER_HTTP_PORT || \"8789\");\n+\n+  if (!PROGRAM_ID) throw new Error(\"missing DDNS_REP_PROGRAM_ID\");\n+\n+  const wallet = loadKeypair(WALLET);\n+  const conn = new anchor.web3.Connection(RPC_URL, \"confirmed\");\n+  const provider = new anchor.AnchorProvider(conn, new anchor.Wallet(wallet), { commitment: \"confirmed\" });\n+  anchor.setProvider(provider);\n+  const idl: any = loadRepIdl();\n+  idl.address = PROGRAM_ID;\n+  const program: any = new (anchor as any).Program(idl, provider);\n+\n+  if (SERVE) {\n+    const server = http.createServer(async (req, res) => {\n+      if (req.method === \"POST\" && req.url === \"/v1/submit\") {\n+        try {","path":"services/miner-node/src/index.ts","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The relay endpoint accepts unauthenticated POSTs and will immediately submit an on-chain transaction using the miner’s wallet. If this service binds to a non-loopback interface (or is port-forwarded), anyone can trigger SOL fee spending / spam submissions. Consider requiring an auth token (e.g., shared secret header) and rejecting requests without it.","created_at":"2026-02-18T09:30:44Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278944","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278944"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278944"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278944/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":147,"original_start_line":145,"start_side":"RIGHT","line":148,"original_line":146,"side":"RIGHT","author_association":"NONE","original_position":146,"position":148,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278981","pull_request_review_id":3818737933,"id":2821278981,"node_id":"PRRC_kwDORKbd9s6oKU0F","diff_hunk":"@@ -0,0 +1,215 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import crypto from \"node:crypto\";\n+import http from \"node:http\";\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { PublicKey, Keypair, SystemProgram } from \"@solana/web3.js\";\n+\n+type DnsAnswer = { name: string; type: number; TTL: number; data: string };\n+type ReceiptLike = { name: string; name_hash: string; rrset_hash: string; colo?: string };\n+\n+function loadKeypair(filePath: string): Keypair {\n+  return Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs.readFileSync(filePath, \"utf8\"))));\n+}\n+\n+function sha256(buf: Buffer): Buffer {\n+  return crypto.createHash(\"sha256\").update(buf).digest();\n+}\n+\n+function nameHash(name: string): Buffer {\n+  return sha256(Buffer.from(name.trim().toLowerCase(), \"utf8\"));\n+}\n+\n+function rrsetHash(answers: DnsAnswer[]): Buffer {\n+  const canon = answers\n+    .map((a) => `${a.name.toLowerCase()}|${a.type}|${a.data}|${a.TTL}`)\n+    .sort()\n+    .join(\"\\n\");\n+  return sha256(Buffer.from(canon, \"utf8\"));\n+}\n+\n+function merkleRoot(leaves: Buffer[]): Buffer {\n+  if (leaves.length === 0) return Buffer.alloc(32, 0);\n+  let level = leaves.map((l) => sha256(l));\n+  while (level.length > 1) {\n+    const next: Buffer[] = [];\n+    for (let i = 0; i < level.length; i += 2) {\n+      const a = level[i];\n+      const b = i + 1 < level.length ? level[i + 1] : a;\n+      next.push(sha256(Buffer.concat([a, b])));\n+    }\n+    level = next;\n+  }\n+  return level[0];\n+}\n+\n+async function dohResolve(upstream: string, name: string, qtype: string): Promise<DnsAnswer[]> {\n+  const u = new URL(upstream);\n+  u.searchParams.set(\"name\", name);\n+  u.searchParams.set(\"type\", qtype);\n+  const r = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" } });\n+  if (!r.ok) throw new Error(`upstream_${r.status}`);\n+  const j: any = await r.json();\n+  return Array.isArray(j?.Answer) ? j.Answer : [];\n+}\n+\n+function readProgramIdFromAnchorToml(rpcUrl: string): string | null {\n+  const p = path.resolve(process.cwd(), \"../../solana/Anchor.toml\");\n+  if (!fs.existsSync(p)) return null;\n+  const content = fs.readFileSync(p, \"utf8\");\n+  const section = /localhost|127\\.0\\.0\\.1/.test(rpcUrl) ? \"programs.localnet\" : \"programs.devnet\";\n+  const re = new RegExp(`\\\\[${section}\\\\][^\\\\[]*?ddns_rep\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"`, \"s\");\n+  const m = content.match(re);\n+  return m ? m[1] : null;\n+}\n+\n+function loadRepIdl() {\n+  const p = path.resolve(process.cwd(), \"../../solana/target/idl/ddns_rep.json\");\n+  if (!fs.existsSync(p)) throw new Error(`missing idl at ${p}; run anchor build in solana/ first`);\n+  return JSON.parse(fs.readFileSync(p, \"utf8\"));\n+}\n+\n+function leavesFromReceipts(receipts: ReceiptLike[]): { leaves: Buffer[]; uniqueNames: number; uniqueColos: number } {\n+  const leaves = receipts.map((r) => {\n+    const nh = /^[0-9a-fA-F]{64}$/.test(r.name_hash)\n+      ? Buffer.from(r.name_hash, \"hex\")\n+      : nameHash(r.name);\n+    const dh = /^[0-9a-fA-F]{64}$/.test(r.rrset_hash)\n+      ? Buffer.from(r.rrset_hash, \"hex\")\n+      : sha256(Buffer.from(r.rrset_hash, \"utf8\"));\n+    const colo = sha256(Buffer.from(r.colo || \"unknown\", \"utf8\"));\n+    return Buffer.concat([nh, dh, colo]);\n+  });\n+  const uniqueNames = new Set(receipts.map((r) => r.name_hash || r.name.toLowerCase())).size;\n+  const uniqueColos = new Set(receipts.map((r) => r.colo || \"unknown\")).size;\n+  return { leaves, uniqueNames, uniqueColos };\n+}\n+\n+async function submitAward(\n+  program: any,\n+  wallet: Keypair,\n+  epochId: number,\n+  leaves: Buffer[],\n+  uniqueNames: number,\n+  uniqueColos: number,\n+) {\n+  const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+  const [bondPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_bond\"), wallet.publicKey.toBuffer()], program.programId);\n+  const [repPda] = PublicKey.findProgramAddressSync([Buffer.from(\"miner_rep\"), wallet.publicKey.toBuffer()], program.programId);\n+\n+  const root = merkleRoot(leaves);\n+  const sig = await program.methods\n+    .awardRep(new anchor.BN(epochId), [...root], leaves.length, uniqueNames, uniqueColos)\n+    .accounts({\n+      miner: wallet.publicKey,\n+      config: configPda,\n+      bond: bondPda,\n+      rep: repPda,\n+      systemProgram: SystemProgram.programId,\n+    })\n+    .signers([wallet])\n+    .rpc();\n+\n+  return { sig, root: root.toString(\"hex\"), repPda: repPda.toBase58() };\n+}\n+\n+async function main() {\n+  const RPC_URL = process.env.SOLANA_RPC_URL || process.env.ANCHOR_PROVIDER_URL || \"https://api.devnet.solana.com\";\n+  const WALLET = process.env.MINER_WALLET || process.env.ANCHOR_WALLET || path.join(process.env.HOME || \".\", \".config/solana/id.json\");\n+  const PROGRAM_ID = process.env.DDNS_REP_PROGRAM_ID || readProgramIdFromAnchorToml(RPC_URL);\n+  const NAMES = (process.env.MINER_NAMES || \"example.com,netflix.com,cloudflare.com\")\n+    .split(\",\")\n+    .map((s) => s.trim())\n+    .filter(Boolean);\n+  const QTYPE = process.env.MINER_QTYPE || \"A\";\n+  const COLO = process.env.MINER_COLO || \"local-node\";\n+  const DOH = (process.env.RECURSIVE_UPSTREAMS || \"https://cloudflare-dns.com/dns-query,https://dns.google/resolve\")\n+    .split(\",\")\n+    .map((s) => s.trim())\n+    .filter(Boolean);\n+  const SERVE = process.env.MINER_HTTP === \"1\";\n+  const PORT = Number(process.env.MINER_HTTP_PORT || \"8789\");\n+\n+  if (!PROGRAM_ID) throw new Error(\"missing DDNS_REP_PROGRAM_ID\");\n+\n+  const wallet = loadKeypair(WALLET);\n+  const conn = new anchor.web3.Connection(RPC_URL, \"confirmed\");\n+  const provider = new anchor.AnchorProvider(conn, new anchor.Wallet(wallet), { commitment: \"confirmed\" });\n+  anchor.setProvider(provider);\n+  const idl: any = loadRepIdl();\n+  idl.address = PROGRAM_ID;\n+  const program: any = new (anchor as any).Program(idl, provider);\n+\n+  if (SERVE) {\n+    const server = http.createServer(async (req, res) => {\n+      if (req.method === \"POST\" && req.url === \"/v1/submit\") {\n+        try {\n+          const body = await new Promise<string>((resolve, reject) => {\n+            let data = \"\";\n+            req.on(\"data\", (c) => (data += String(c)));\n+            req.on(\"end\", () => resolve(data));\n+            req.on(\"error\", reject);","path":"services/miner-node/src/index.ts","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Request body is accumulated without any size limit before JSON parsing. A large payload can cause high memory usage and potentially crash the relay (DoS). Add a maximum body size (and abort/close the connection when exceeded).","created_at":"2026-02-18T09:30:44Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278981","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278981"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821278981"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821278981/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":149,"original_start_line":147,"start_side":"RIGHT","line":153,"original_line":151,"side":"RIGHT","author_association":"NONE","original_position":151,"position":153,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279015","pull_request_review_id":3818737933,"id":2821279015,"node_id":"PRRC_kwDORKbd9s6oKU0n","diff_hunk":"@@ -0,0 +1,70 @@\n+export interface Env {\n+  MINER_API_URL: string;\n+  DOH_URL: string;\n+  NAMES: string;\n+  QTYPE: string;\n+  COLO_FALLBACK?: string;\n+}\n+\n+type DnsAnswer = { name: string; type: number; TTL: number; data: string };\n+\n+function bytesToHex(buf: ArrayBuffer): string {\n+  const bytes = new Uint8Array(buf);\n+  let out = \"\";\n+  for (const b of bytes) out += b.toString(16).padStart(2, \"0\");\n+  return out;\n+}\n+\n+async function resolveDns(doh: string, name: string, qtype: string): Promise<DnsAnswer[]> {\n+  const u = new URL(doh);\n+  u.searchParams.set(\"name\", name);\n+  u.searchParams.set(\"type\", qtype);\n+  const r = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" } });\n+  if (!r.ok) throw new Error(`upstream_${r.status}`);\n+  const j: any = await r.json();\n+  return Array.isArray(j?.Answer) ? j.Answer : [];\n+}\n+\n+export default {\n+  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n+    const url = new URL(request.url);\n+    if (url.pathname !== \"/run\") {\n+      return new Response(\"ok\", { status: 200 });\n+    }","path":"services/miner-worker-cloudflare/src/index.ts","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`/run` is a public endpoint that triggers DNS resolution work and then POSTs to the miner relay. Without any authentication/authorization, anyone can repeatedly call it and drive egress/costs and spam the relay. Consider requiring a shared secret header/query param, or moving this to a scheduled trigger and rejecting public requests.","created_at":"2026-02-18T09:30:44Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279015","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279015"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279015"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279015/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":30,"original_start_line":30,"start_side":"RIGHT","line":33,"original_line":33,"side":"RIGHT","author_association":"NONE","original_position":33,"position":33,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279041","pull_request_review_id":3818737933,"id":2821279041,"node_id":"PRRC_kwDORKbd9s6oKU1B","diff_hunk":"@@ -0,0 +1,150 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import crypto from \"node:crypto\";\n+import yargs from \"yargs\";\n+import { hideBin } from \"yargs/helpers\";\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { Keypair, PublicKey, SystemProgram } from \"@solana/web3.js\";\n+import BN from \"bn.js\";\n+\n+function loadKeypair(filePath: string): Keypair {\n+  return Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs.readFileSync(filePath, \"utf8\"))));\n+}\n+\n+function readProgramIdFromAnchorToml(rpcUrl: string): string | null {\n+  const p = path.resolve(\"Anchor.toml\");\n+  if (!fs.existsSync(p)) return null;\n+  const content = fs.readFileSync(p, \"utf8\");\n+  const section = /localhost|127\\.0\\.0\\.1/.test(rpcUrl) ? \"programs.localnet\" : \"programs.devnet\";\n+  const re = new RegExp(`\\\\[${section}\\\\][^\\\\[]*?ddns_rep\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"`, \"s\");\n+  const m = content.match(re);\n+  return m ? m[1] : null;\n+}\n+\n+function loadIdl() {\n+  const p = path.resolve(\"target/idl/ddns_rep.json\");\n+  if (!fs.existsSync(p)) throw new Error(`IDL missing at ${p}. Run anchor build first.`);\n+  return JSON.parse(fs.readFileSync(p, \"utf8\"));\n+}\n+\n+function sha256Hex(s: string): Buffer {\n+  return crypto.createHash(\"sha256\").update(Buffer.from(s, \"utf8\")).digest();\n+}\n+\n+async function main() {\n+  const argv = await yargs(hideBin(process.argv))\n+    .command(\"init-config\", \"init rep config\", (y) =>\n+      y\n+        .option(\"epoch-len-slots\", { type: \"number\", default: 100 })\n+        .option(\"daily-cap\", { type: \"string\", default: \"1000\" })\n+        .option(\"min-bond-lamports\", { type: \"string\", default: \"10000000\" })\n+        .option(\"min-unique-names\", { type: \"number\", default: 3 })\n+        .option(\"min-unique-colos\", { type: \"number\", default: 1 })\n+        .option(\"rep-per-aggregate\", { type: \"string\", default: \"20\" })\n+        .option(\"rep-decay-per-epoch\", { type: \"string\", default: \"0\" })\n+        .option(\"cooldown-slots\", { type: \"string\", default: \"150\" })\n+        .option(\"enabled\", { type: \"boolean\", default: true })\n+    )\n+    .command(\"deposit-bond\", \"deposit SOL bond\", (y) => y.option(\"amount\", { type: \"string\", demandOption: true }))\n+    .command(\"withdraw-bond\", \"withdraw SOL bond\", (y) => y.option(\"amount\", { type: \"string\", demandOption: true }))\n+    .command(\"award\", \"submit aggregate for REP\", (y) =>\n+      y\n+        .option(\"epoch\", { type: \"number\", demandOption: true })","path":"solana/scripts/rep.ts","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The `award --epoch` option is parsed as a JS `number` and later passed to `new BN(argv.epoch as number)`. For u64 values this can silently lose precision above 2^53-1. Prefer taking `--epoch` as a string (or bigint) and constructing `BN` from the string.\n```suggestion\n        .option(\"epoch\", { type: \"string\", demandOption: true })\n```","created_at":"2026-02-18T09:30:45Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279041","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279041"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279041"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279041/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":52,"original_line":52,"side":"RIGHT","author_association":"NONE","original_position":52,"position":52,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279057","pull_request_review_id":3818737933,"id":2821279057,"node_id":"PRRC_kwDORKbd9s6oKU1R","diff_hunk":"@@ -0,0 +1,215 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import crypto from \"node:crypto\";\n+import http from \"node:http\";\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { PublicKey, Keypair, SystemProgram } from \"@solana/web3.js\";\n+\n+type DnsAnswer = { name: string; type: number; TTL: number; data: string };\n+type ReceiptLike = { name: string; name_hash: string; rrset_hash: string; colo?: string };\n+\n+function loadKeypair(filePath: string): Keypair {\n+  return Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs.readFileSync(filePath, \"utf8\"))));\n+}\n+\n+function sha256(buf: Buffer): Buffer {\n+  return crypto.createHash(\"sha256\").update(buf).digest();\n+}\n+\n+function nameHash(name: string): Buffer {\n+  return sha256(Buffer.from(name.trim().toLowerCase(), \"utf8\"));\n+}\n+\n+function rrsetHash(answers: DnsAnswer[]): Buffer {\n+  const canon = answers\n+    .map((a) => `${a.name.toLowerCase()}|${a.type}|${a.data}|${a.TTL}`)\n+    .sort()\n+    .join(\"\\n\");\n+  return sha256(Buffer.from(canon, \"utf8\"));\n+}\n+\n+function merkleRoot(leaves: Buffer[]): Buffer {\n+  if (leaves.length === 0) return Buffer.alloc(32, 0);\n+  let level = leaves.map((l) => sha256(l));\n+  while (level.length > 1) {\n+    const next: Buffer[] = [];\n+    for (let i = 0; i < level.length; i += 2) {\n+      const a = level[i];\n+      const b = i + 1 < level.length ? level[i + 1] : a;\n+      next.push(sha256(Buffer.concat([a, b])));\n+    }\n+    level = next;\n+  }\n+  return level[0];\n+}\n+\n+async function dohResolve(upstream: string, name: string, qtype: string): Promise<DnsAnswer[]> {\n+  const u = new URL(upstream);\n+  u.searchParams.set(\"name\", name);\n+  u.searchParams.set(\"type\", qtype);\n+  const r = await fetch(u.toString(), { headers: { accept: \"application/dns-json\" } });\n+  if (!r.ok) throw new Error(`upstream_${r.status}`);\n+  const j: any = await r.json();\n+  return Array.isArray(j?.Answer) ? j.Answer : [];\n+}\n+\n+function readProgramIdFromAnchorToml(rpcUrl: string): string | null {\n+  const p = path.resolve(process.cwd(), \"../../solana/Anchor.toml\");\n+  if (!fs.existsSync(p)) return null;\n+  const content = fs.readFileSync(p, \"utf8\");\n+  const section = /localhost|127\\.0\\.0\\.1/.test(rpcUrl) ? \"programs.localnet\" : \"programs.devnet\";\n+  const re = new RegExp(`\\\\[${section}\\\\][^\\\\[]*?ddns_rep\\\\s*=\\\\s*\\\"([^\\\"]+)\\\"`, \"s\");\n+  const m = content.match(re);\n+  return m ? m[1] : null;\n+}\n+\n+function loadRepIdl() {\n+  const p = path.resolve(process.cwd(), \"../../solana/target/idl/ddns_rep.json\");\n+  if (!fs.existsSync(p)) throw new Error(`missing idl at ${p}; run anchor build in solana/ first`);\n+  return JSON.parse(fs.readFileSync(p, \"utf8\"));\n+}\n+\n+function leavesFromReceipts(receipts: ReceiptLike[]): { leaves: Buffer[]; uniqueNames: number; uniqueColos: number } {\n+  const leaves = receipts.map((r) => {\n+    const nh = /^[0-9a-fA-F]{64}$/.test(r.name_hash)\n+      ? Buffer.from(r.name_hash, \"hex\")\n+      : nameHash(r.name);\n+    const dh = /^[0-9a-fA-F]{64}$/.test(r.rrset_hash)\n+      ? Buffer.from(r.rrset_hash, \"hex\")\n+      : sha256(Buffer.from(r.rrset_hash, \"utf8\"));\n+    const colo = sha256(Buffer.from(r.colo || \"unknown\", \"utf8\"));\n+    return Buffer.concat([nh, dh, colo]);\n+  });\n+  const uniqueNames = new Set(receipts.map((r) => r.name_hash || r.name.toLowerCase())).size;\n+  const uniqueColos = new Set(receipts.map((r) => r.colo || \"unknown\")).size;","path":"services/miner-node/src/index.ts","commit_id":"964354155f71b8d46751bc9dd43264cf72638ff0","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`uniqueNames` is computed from `r.name_hash || r.name.toLowerCase()`, but leaf construction falls back to hashing `r.name` when `name_hash` is not valid hex. This lets a caller inflate `uniqueNames` by sending distinct invalid `name_hash` strings while leaves still use the same `name`. Compute uniqueness from the same validated/derived value actually used for the leaf.\n```suggestion\n  const nameSet = new Set<string>();\n  const coloSet = new Set<string>();\n  const leaves = receipts.map((r) => {\n    const nh = /^[0-9a-fA-F]{64}$/.test(r.name_hash)\n      ? Buffer.from(r.name_hash, \"hex\")\n      : nameHash(r.name);\n    // Track unique names based on the effective name hash used in the leaf.\n    nameSet.add(nh.toString(\"hex\"));\n    const dh = /^[0-9a-fA-F]{64}$/.test(r.rrset_hash)\n      ? Buffer.from(r.rrset_hash, \"hex\")\n      : sha256(Buffer.from(r.rrset_hash, \"utf8\"));\n    const coloKey = r.colo || \"unknown\";\n    // Track unique colos based on the same key used to derive the colo hash.\n    coloSet.add(coloKey);\n    const colo = sha256(Buffer.from(coloKey, \"utf8\"));\n    return Buffer.concat([nh, dh, colo]);\n  });\n  const uniqueNames = nameSet.size;\n  const uniqueColos = coloSet.size;\n```","created_at":"2026-02-18T09:30:45Z","updated_at":"2026-02-18T09:30:47Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279057","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279057"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279057"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279057/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":73,"original_start_line":73,"start_side":"RIGHT","line":84,"original_line":84,"side":"RIGHT","author_association":"NONE","original_position":84,"position":84,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279085","pull_request_review_id":3818737933,"id":2821279085,"node_id":"PRRC_kwDORKbd9s6oKU1t","diff_hunk":"@@ -0,0 +1,168 @@\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { Program } from \"@coral-xyz/anchor\";\n+import { expect } from \"chai\";\n+import { Keypair, PublicKey, SystemProgram, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n+import BN from \"bn.js\";\n+\n+function u64le(n: bigint): Buffer {\n+  const b = Buffer.alloc(8);\n+  b.writeBigUInt64LE(n);\n+  return b;\n+}\n+\n+describe(\"ddns_rep\", () => {\n+  const provider = anchor.AnchorProvider.env();\n+  anchor.setProvider(provider);\n+\n+  const program = anchor.workspace.DdnsRep as Program;\n+\n+  it(\"bond gate + award rep + daily cap + duplicate root\", async () => {\n+    const feePayer = (provider.wallet as any).payer as Keypair;\n+    const authority = feePayer.publicKey;\n+\n+    const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+\n+    await program.methods\n+      .initRepConfig(\n+        new BN(1000), // epoch_len_slots\n+        new BN(50), // daily cap\n+        new BN(10_000_000), // min bond\n+        2, // min unique names\n+        1, // min unique colos\n+        new BN(40), // rep per valid aggregate\n+        new BN(0), // no decay\n+        new BN(0), // cooldown slots\n+        true\n+      )\n+      .accounts({\n+        authority,\n+        config: configPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .rpc();\n+\n+    const miner = Keypair.generate();\n+    const dropSig = await provider.connection.requestAirdrop(miner.publicKey, LAMPORTS_PER_SOL);\n+    await provider.connection.confirmTransaction(dropSig, \"confirmed\");\n+\n+    const [bondPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"rep_bond\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+    const [repPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"miner_rep\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+\n+    await program.methods\n+      .depositRepBond(new BN(20_000_000))\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    const slot = await provider.connection.getSlot(\"confirmed\");\n+    const epoch = BigInt(Math.floor(slot / 1000));\n+\n+    const rootA = Array.from({ length: 32 }, (_, i) => (i + 1) % 255);\n+    await program.methods\n+      .awardRep(new BN(epoch.toString()), rootA, 100, 2, 1)\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        rep: repPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    // duplicate root must fail\n+    try {\n+      await program.methods\n+        .awardRep(new BN(epoch.toString()), rootA, 100, 2, 1)\n+        .accounts({\n+          miner: miner.publicKey,\n+          config: configPda,\n+          bond: bondPda,\n+          rep: repPda,\n+          systemProgram: SystemProgram.programId,\n+        })\n+        .signers([miner])\n+        .rpc();\n+      expect.fail(\"expected duplicate root failure\");\n+    } catch (e: any) {\n+      expect(String(e)).to.match(/DuplicateRoot|duplicate/i);\n+    }\n+\n+    // second unique root should be capped by daily cap (50 total).\n+    const rootB = Array.from({ length: 32 }, (_, i) => (i + 2) % 255);\n+    await program.methods\n+      .awardRep(new BN(epoch.toString()), rootB, 100, 10, 2)\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,\n+        bond: bondPda,\n+        rep: repPda,\n+        systemProgram: SystemProgram.programId,\n+      })\n+      .signers([miner])\n+      .rpc();\n+\n+    const rep: any = await program.account.minerRep.fetch(repPda);\n+    expect(Number(rep.repTotal)).to.equal(50);\n+    expect(Number(rep.repToday)).to.equal(50);\n+  });\n+\n+  it(\"rejects award when diversity below minimum\", async () => {\n+    const miner = Keypair.generate();\n+    const dropSig = await provider.connection.requestAirdrop(miner.publicKey, LAMPORTS_PER_SOL);\n+    await provider.connection.confirmTransaction(dropSig, \"confirmed\");\n+\n+    const [configPda] = PublicKey.findProgramAddressSync([Buffer.from(\"rep_config\")], program.programId);\n+    const [bondPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"rep_bond\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+    const [repPda] = PublicKey.findProgramAddressSync(\n+      [Buffer.from(\"miner_rep\"), miner.publicKey.toBuffer()],\n+      program.programId\n+    );\n+\n+    await program.methods\n+      .depositRepBond(new BN(20_000_000))\n+      .accounts({\n+        miner: miner.publicKey,\n+        config: configPda,","path":"solana/tests/ddns_rep.ts","commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","original_commit_id":"58176249385be3605dec24e0b55bb4ef07c5a25f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"This test deposits bond against `configPda` without ensuring the `rep_config` PDA has been initialized in this test (it currently relies on the prior test to have run first). That makes the suite order-dependent and can be flaky when running tests in isolation. Consider initializing the config in a `before` hook (idempotently) or in this test when missing.","created_at":"2026-02-18T09:30:45Z","updated_at":"2026-02-18T09:30:45Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279085","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279085"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/64#discussion_r2821279085"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/64"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821279085/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":136,"start_side":"RIGHT","line":null,"original_line":140,"side":"RIGHT","author_association":"NONE","original_position":140,"position":1,"subject_type":"line"}]