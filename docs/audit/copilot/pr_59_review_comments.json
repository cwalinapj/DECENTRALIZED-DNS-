[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071943","pull_request_review_id":3818523906,"id":2821071943,"node_id":"PRRC_kwDORKbd9s6oJiRH","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`append_run_log` writes to `docs/MERGE_LOG.md` inside the repo, which will make the repo dirty after the first log entry. Because the script later enforces `require_clean_repo` (and also re-checks it per PR), this will block processing multiple PRs in one run and will block subsequent runs unless the user commits/stashes the log change. Consider writing logs outside the Git working tree (e.g., under a temp dir) or explicitly excluding the log file from the cleanliness check.\n```suggestion\n  # Write logs outside the Git working tree to avoid dirtying the repo.\n  # Allow override via MERGE_GUARD_LOG_FILE; default to a file next to the repo root.\n  local log_file=\"${MERGE_GUARD_LOG_FILE:-\"$ROOT/../MERGE_LOG.md\"}\"\n  mkdir -p \"$(dirname \"$log_file\")\"\n  {\n    echo \"## $ts\"\n    echo \"- status: $status\"\n    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n    echo \"- detail: $detail\"\n    echo\n  } >> \"$log_file\"\n```","created_at":"2026-02-18T08:47:07Z","updated_at":"2026-02-18T08:47:10Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071943","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071943"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071943"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071943/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":36,"original_start_line":36,"start_side":"RIGHT","line":42,"original_line":42,"side":"RIGHT","author_association":"NONE","original_position":42,"position":42,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071978","pull_request_review_id":3818523906,"id":2821071978,"node_id":"PRRC_kwDORKbd9s6oJiRq","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Creating `$ROOT/.worktrees` inside the repository will show up as an untracked path unless it’s ignored, which conflicts with the script’s `require_clean_repo` guardrails. Consider using a temp directory outside the repo (e.g., under `$TMPDIR`) or ensure `.worktrees/` is ignored and excluded from the cleanliness check.\n```suggestion\n  worktree_root=\"${TMPDIR:-/tmp}/merge_prs_one_by_one-worktrees\"\n  wt=\"$worktree_root/pr-$pr-$ts\"\n  int_branch=\"merge-guard-pr-$pr-$ts\"\n\n  run \"mkdir -p '$worktree_root'\"\n```","created_at":"2026-02-18T08:47:07Z","updated_at":"2026-02-18T08:47:10Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071978","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071978"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071978"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071978/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":181,"original_start_line":181,"start_side":"RIGHT","line":184,"original_line":184,"side":"RIGHT","author_association":"NONE","original_position":184,"position":184,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071994","pull_request_review_id":3818523906,"id":2821071994,"node_id":"PRRC_kwDORKbd9s6oJiR6","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The script assumes `headRefName` is fetchable from the `origin` remote (`git fetch origin ... '$head_ref'` / `origin/$head_ref`). For PRs from forks, this generally won’t exist on `origin`, so the flow will fail. Consider querying `isCrossRepository`/head repo info via `gh pr view` and either abort with a clear error or fetch from the correct remote/ref.","created_at":"2026-02-18T08:47:07Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071994","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071994"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821071994"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821071994/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":154,"original_start_line":154,"start_side":"RIGHT","line":157,"original_line":157,"side":"RIGHT","author_association":"NONE","original_position":157,"position":157,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072019","pull_request_review_id":3818523906,"id":2821072019,"node_id":"PRRC_kwDORKbd9s6oJiST","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"\n+  run \"git fetch origin main '$head_ref'\"\n+  run \"git worktree add '$wt' -b '$int_branch' 'origin/$head_ref'\"\n+  run \"cd '$wt' && git fetch origin main && git rebase origin/main\"\n+","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`run \"cd '$wt' && ...\"` is executed in the current shell (because `run()` uses `eval`), so it permanently changes the script’s working directory to the worktree. That makes later steps fragile (notably `git worktree remove` can fail if the current directory is inside the worktree). Prefer `git -C \"$wt\" ...` or running the `cd` in a subshell so the working directory doesn’t leak.","created_at":"2026-02-18T08:47:08Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072019","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072019"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072019"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072019/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":187,"original_start_line":187,"start_side":"RIGHT","line":188,"original_line":188,"side":"RIGHT","author_association":"NONE","original_position":188,"position":188,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072029","pull_request_review_id":3818523906,"id":2821072029,"node_id":"PRRC_kwDORKbd9s6oJiSd","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Once a worktree is created, any subsequent failure causes an immediate exit (`set -e`) and can leave behind `$wt` and the intermediate branch. Consider adding a `trap` that attempts to remove the worktree (and optionally delete `$int_branch`) on EXIT/ERR so reruns don’t accumulate stale worktrees.","created_at":"2026-02-18T08:47:08Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072029","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072029"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072029"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072029/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":180,"original_start_line":180,"start_side":"RIGHT","line":184,"original_line":184,"side":"RIGHT","author_association":"NONE","original_position":184,"position":184,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072044","pull_request_review_id":3818523906,"id":2821072044,"node_id":"PRRC_kwDORKbd9s6oJiSs","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"\n+  run \"git fetch origin main '$head_ref'\"\n+  run \"git worktree add '$wt' -b '$int_branch' 'origin/$head_ref'\"\n+  run \"cd '$wt' && git fetch origin main && git rebase origin/main\"\n+\n+  if [[ -d \"$wt/packages/attack-mode\" ]]; then\n+    run_local_check \"$wt\" \"npm -C packages/attack-mode ci && npm -C packages/attack-mode run build\"\n+  fi\n+  if [[ -d \"$wt/services/miner-witness\" ]]; then\n+    run_local_check \"$wt\" \"npm -C services/miner-witness ci && npm -C services/miner-witness test && npm -C services/miner-witness run build\"\n+  fi\n+  if [[ -d \"$wt/solana\" ]]; then\n+    run_local_check \"$wt\" \"cd solana && cargo generate-lockfile\"\n+    run_local_check \"$wt\" \"cd solana && anchor build\"\n+  fi\n+\n+  run \"cd '$wt' && git push --force-with-lease origin HEAD:'$head_ref'\"\n+\n+  if [[ -n \"$OVERRIDE_TOKEN\" ]]; then\n+    log \"OVERRIDE token provided; merge is allowed by script policy.\"\n+    run \"gh pr merge '$pr' --squash --delete-branch\"\n+    run \"git checkout main && git pull --ff-only\"\n+    if [[ -d \"$ROOT/services/miner-witness\" ]]; then\n+      run \"npm -C '$ROOT/services/miner-witness' test\"\n+    fi\n+    if [[ -d \"$ROOT/solana\" ]]; then\n+      run \"cd '$ROOT/solana' && anchor build\"\n+    fi\n+    append_run_log \"merged\" \"pr-$pr merged with override token\"\n+  else\n+    log \"READY TO MERGE: PR #$pr\"\n+    append_run_log \"ready\" \"pr-$pr checks+rebase+local-checks green\"\n+  fi\n+\n+  run \"git worktree remove '$wt'\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"`git worktree remove '$wt'` will fail if the script’s current directory is inside `$wt` (which can happen due to earlier `cd` commands executed via `run`). Ensure you `cd \"$ROOT\"` (or use `git -C \"$ROOT\" worktree remove ...`) before removal to make cleanup reliable.\n```suggestion\n  run \"git -C '$ROOT' worktree remove '$wt'\"\n```","created_at":"2026-02-18T08:47:08Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072044","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072044"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072044"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072044/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":218,"original_line":218,"side":"RIGHT","author_association":"NONE","original_position":218,"position":218,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072056","pull_request_review_id":3818523906,"id":2821072056,"node_id":"PRRC_kwDORKbd9s6oJiS4","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"\n+  run \"git fetch origin main '$head_ref'\"\n+  run \"git worktree add '$wt' -b '$int_branch' 'origin/$head_ref'\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The `run` wrapper uses `eval` on a single string, and `head_ref` is interpolated into that string only inside single quotes. Because Git/GitHub allow branch names containing characters like `'`, `;`, and `#`, a malicious PR branch name (e.g. from a fork) can break out of the quotes and inject arbitrary shell commands when `run` executes this `git fetch`/`git worktree add` call. Refactor this to avoid `eval` and pass `head_ref` as a normal, properly quoted argument (or at minimum, robustly escape single quotes in `head_ref` before interpolation).","created_at":"2026-02-18T08:47:08Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072056","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072056"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072056"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072056/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":185,"original_start_line":185,"start_side":"RIGHT","line":186,"original_line":186,"side":"RIGHT","author_association":"NONE","original_position":186,"position":186,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072064","pull_request_review_id":3818523906,"id":2821072064,"node_id":"PRRC_kwDORKbd9s6oJiTA","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"\n+}\n+\n+append_run_log() {\n+  local status=\"$1\"\n+  local detail=\"$2\"\n+  local ts\n+  ts=\"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"\n+  {\n+    echo \"## $ts\"\n+    echo \"- status: $status\"\n+    echo \"- mode: $( [[ -n \"$LABEL\" ]] && echo \"label:$LABEL\" || echo \"prs:${ITEMS[*]:-none}\" )\"\n+    echo \"- detail: $detail\"\n+    echo\n+  } >> \"$ROOT/docs/MERGE_LOG.md\"\n+}\n+\n+is_repo_clean() {\n+  local merge_head rebase_head cherry_head status\n+  merge_head=\"$(git rev-parse --git-path MERGE_HEAD)\"\n+  rebase_head=\"$(git rev-parse --git-path REBASE_HEAD)\"\n+  cherry_head=\"$(git rev-parse --git-path CHERRY_PICK_HEAD)\"\n+  status=\"$(git status --porcelain)\"\n+\n+  [[ ! -f \"$merge_head\" ]] || return 1\n+  [[ ! -f \"$rebase_head\" ]] || return 1\n+  [[ ! -f \"$cherry_head\" ]] || return 1\n+  [[ -z \"$status\" ]] || return 1\n+  return 0\n+}\n+\n+require_clean_repo() {\n+  if ! is_repo_clean; then\n+    log \"ERROR: Repository is not clean (conflict or local changes detected).\"\n+    git status --porcelain || true\n+    append_run_log \"blocked\" \"dirty-or-conflicted-repo-state\"\n+    exit 1\n+  fi\n+}\n+\n+require_main_green() {\n+  local conclusion\n+  conclusion=\"$(gh run list --branch main -L 1 --json conclusion --jq '.[0].conclusion // \"unknown\"')\"\n+  if [[ \"$conclusion\" != \"success\" ]]; then\n+    log \"ERROR: main CI is not green (latest: $conclusion).\"\n+    append_run_log \"blocked\" \"main-ci-not-green:$conclusion\"\n+    exit 1\n+  fi\n+}\n+\n+collect_prs() {\n+  local prs=()\n+  if [[ -n \"$LABEL\" ]]; then\n+    mapfile -t prs < <(gh pr list --state open --label \"$LABEL\" --json number --jq '.[].number')\n+  else\n+    for item in \"${ITEMS[@]}\"; do\n+      if [[ \"$item\" =~ ^[0-9]+$ ]]; then\n+        prs+=(\"$item\")\n+      else\n+        log \"ERROR: Only PR numbers are supported in positional mode.\"\n+        append_run_log \"blocked\" \"invalid-positional-item:$item\"\n+        exit 1\n+      fi\n+    done\n+  fi\n+\n+  if [[ \"${#prs[@]}\" -eq 0 ]]; then\n+    log \"No PRs found for the given input.\"\n+    append_run_log \"noop\" \"no-prs-found\"\n+    exit 0\n+  fi\n+\n+  printf '%s\\n' \"${prs[@]}\"\n+}\n+\n+run_local_check() {\n+  local wt=\"$1\"\n+  local cmd=\"$2\"\n+  log \"local-check: $cmd\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] (cd '$wt' && $cmd)\"\n+    return 0\n+  fi\n+  if ! (cd \"$wt\" && eval \"$cmd\"); then\n+    log \"ERROR: local check failed: (cd '$wt' && $cmd)\"\n+    append_run_log \"blocked\" \"local-check-failed:$cmd\"\n+    exit 1\n+  fi\n+}\n+\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --dry-run)\n+      DRY_RUN=1\n+      shift\n+      ;;\n+    --label)\n+      LABEL=\"${2:-}\"\n+      [[ -z \"$LABEL\" ]] && { usage; exit 1; }\n+      shift 2\n+      ;;\n+    -h|--help)\n+      usage\n+      exit 0\n+      ;;\n+    *)\n+      ITEMS+=(\"$1\")\n+      shift\n+      ;;\n+  esac\n+done\n+\n+if [[ -z \"$LABEL\" && \"${#ITEMS[@]}\" -eq 0 ]]; then\n+  usage\n+  exit 1\n+fi\n+\n+require_clean_repo\n+require_main_green\n+\n+mapfile -t PRS < <(collect_prs)\n+\n+for pr in \"${PRS[@]}\"; do\n+  require_clean_repo\n+  require_main_green\n+\n+  state=\"$(gh pr view \"$pr\" --json state --jq '.state')\"\n+  base_ref=\"$(gh pr view \"$pr\" --json baseRefName --jq '.baseRefName')\"\n+  head_ref=\"$(gh pr view \"$pr\" --json headRefName --jq '.headRefName')\"\n+\n+  if [[ \"$state\" != \"OPEN\" ]]; then\n+    log \"ERROR: PR #$pr is not open (state=$state).\"\n+    append_run_log \"blocked\" \"pr-$pr-not-open\"\n+    exit 1\n+  fi\n+  if [[ \"$base_ref\" != \"main\" ]]; then\n+    log \"ERROR: PR #$pr base is '$base_ref' (expected 'main').\"\n+    append_run_log \"blocked\" \"pr-$pr-wrong-base:$base_ref\"\n+    exit 1\n+  fi\n+\n+  log \"Watching checks for PR #$pr\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] gh pr checks $pr --watch\"\n+  else\n+    if ! gh pr checks \"$pr\" --watch; then\n+      log \"ERROR: PR #$pr checks failed.\"\n+      append_run_log \"blocked\" \"pr-$pr-checks-failed\"\n+      exit 1\n+    fi\n+  fi\n+\n+  ts=\"$(date +%s)\"\n+  wt=\"$ROOT/.worktrees/pr-$pr-$ts\"\n+  int_branch=\"merge-guard-pr-$pr-$ts\"\n+\n+  run \"mkdir -p '$ROOT/.worktrees'\"\n+  run \"git fetch origin main '$head_ref'\"\n+  run \"git worktree add '$wt' -b '$int_branch' 'origin/$head_ref'\"\n+  run \"cd '$wt' && git fetch origin main && git rebase origin/main\"\n+\n+  if [[ -d \"$wt/packages/attack-mode\" ]]; then\n+    run_local_check \"$wt\" \"npm -C packages/attack-mode ci && npm -C packages/attack-mode run build\"\n+  fi\n+  if [[ -d \"$wt/services/miner-witness\" ]]; then\n+    run_local_check \"$wt\" \"npm -C services/miner-witness ci && npm -C services/miner-witness test && npm -C services/miner-witness run build\"\n+  fi\n+  if [[ -d \"$wt/solana\" ]]; then\n+    run_local_check \"$wt\" \"cd solana && cargo generate-lockfile\"\n+    run_local_check \"$wt\" \"cd solana && anchor build\"\n+  fi\n+\n+  run \"cd '$wt' && git push --force-with-lease origin HEAD:'$head_ref'\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The `run` helper executes its argument via `eval`, and `head_ref` is concatenated into the `git push` command only wrapped in single quotes. Since PR head branch names can contain characters like `'`, `;`, and `#`, an attacker controlling `head_ref` (e.g. via a forked PR) can craft a branch name that breaks out of the quotes and appends arbitrary shell commands when this `git push` runs. To fix this, eliminate `eval` here and pass `head_ref` as a normal argument to `git push`, or rigorously sanitize/escape `head_ref` before using it in any shell-constructed command string.","created_at":"2026-02-18T08:47:08Z","updated_at":"2026-02-18T08:47:11Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072064","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072064"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072064"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072064/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":200,"original_line":200,"side":"RIGHT","author_association":"NONE","original_position":200,"position":200,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072076","pull_request_review_id":3818523906,"id":2821072076,"node_id":"PRRC_kwDORKbd9s6oJiTM","diff_hunk":"@@ -0,0 +1,221 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+\n+ROOT=\"$(git rev-parse --show-toplevel)\"\n+cd \"$ROOT\"\n+\n+DRY_RUN=0\n+LABEL=\"\"\n+OVERRIDE_TOKEN=\"${OVERRIDE_MERGE_OK:-}\"\n+ITEMS=()\n+\n+usage() {\n+  cat <<'USAGE'\n+Usage:\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] --label <label>\n+  ./scripts/merge_prs_one_by_one.sh [--dry-run] <PR#> [PR# ...]\n+USAGE\n+}\n+\n+log() { printf '[merge-guard] %s\\n' \"$*\" >&2; }\n+\n+run() {\n+  local cmd=\"$1\"\n+  if [[ \"$DRY_RUN\" -eq 1 ]]; then\n+    log \"[dry-run] $cmd\"\n+    return 0\n+  fi\n+  eval \"$cmd\"","path":"scripts/merge_prs_one_by_one.sh","commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","original_commit_id":"6f09c13cb5e5b48027f25ff7df19dcfa40457548","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The `run` function is a generic wrapper that takes a single string and executes it with `eval`, and it is used with interpolated values that can originate from PR metadata (such as `head_ref`). Using `eval` on a composed string makes the script vulnerable to command injection whenever any part of that string can be influenced by attacker-controlled data. Replace `eval` with direct command execution using properly quoted arguments (for example, by passing commands and arguments as an array or by restructuring `run` to avoid string-based command construction).\n```suggestion\n  local -a args=()\n  IFS=' ' read -r -a args <<< \"$cmd\"\n  \"${args[@]}\"\n```","created_at":"2026-02-18T08:47:09Z","updated_at":"2026-02-18T08:47:09Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072076","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072076"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/59#discussion_r2821072076"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/59"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821072076/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":28,"original_line":28,"side":"RIGHT","author_association":"NONE","original_position":28,"position":28,"subject_type":"line"}]