[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127609","pull_request_review_id":3821872617,"id":2824127609,"node_id":"PRRC_kwDORKbd9s6oVMR5","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"AVsmrpWUMLsdaHr5Y8p2N96fBMPTHVV7WLz8iiu4nBge\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }\n+\n+        let remaining_epoch_budget = cfg\n+            .max_reward_per_epoch\n+            .saturating_sub(epoch_state.total_accrued_rewards);\n+        let delta_capped = delta_reward.min(remaining_epoch_budget);\n+\n+        stats.submitted_receipts = stats.submitted_receipts.saturating_add(receipt_count);\n+        stats.rewardable_receipts = stats.rewardable_receipts.saturating_add(rewardable);\n+        stats.unique_name_hashes = stats.unique_name_hashes.saturating_add(unique_name_hashes);\n+        stats.unique_colos = stats.unique_colos.saturating_add(unique_colos);\n+        stats.earned_reward = stats.earned_reward.saturating_add(delta_capped);\n+        stats.last_receipts_root = receipts_root;\n+        stats.last_submission_slot = now_slot;\n+\n+        epoch_state.total_submitted_receipts = epoch_state.total_submitted_receipts.saturating_add(receipt_count as u64);\n+        epoch_state.total_rewardable_receipts = epoch_state.total_rewardable_receipts.saturating_add(rewardable as u64);\n+        epoch_state.total_accrued_rewards = epoch_state.total_accrued_rewards.saturating_add(delta_capped);\n+\n+        emit!(BatchSubmitted {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            receipts_root,\n+            receipt_count,\n+            rewardable_receipts: rewardable,\n+            delta_reward: delta_capped,\n+            diversity_bonus_bps,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn claim_rewards(ctx: Context<ClaimRewards>, epoch_id: u64) -> Result<()> {\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+        require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        require!(stats.earned_reward > 0, WitnessRewardsError::NothingToClaim);\n+\n+        let amount = stats.earned_reward;\n+        let cfg = &ctx.accounts.config;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.miner_toll_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.miner.key(),\n+        )?;\n+\n+        let signer_seeds: &[&[u8]] =\n+            &[b\"witness_rewards_vault_authority\", &[cfg.vault_authority_bump]];\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.miner_toll_ata.key(),\n+            &ctx.accounts.vault_authority.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke_signed(\n+            &ix,\n+            &[\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.miner_toll_ata.to_account_info(),\n+                ctx.accounts.vault_authority.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+            &[signer_seeds],\n+        )?;\n+\n+        stats.claimed = true;\n+        emit!(RewardsClaimed {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            amount,\n+        });\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    /// CHECK: validated as SPL mint in instruction.\n+    pub toll_mint: UncheckedAccount<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + WitnessRewardsConfig::SIZE,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA authority for reward vault transfers.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated as SPL token account in instruction.\n+    #[account(mut)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+        has_one = authority @ WitnessRewardsError::Unauthorized,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct FundRewardVault<'info> {\n+    #[account(mut)]\n+    pub funder: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub funder_ata: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    /// CHECK: PDA checked in instruction.","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"c3b5deeda9c82841a7332fc68f59772031771ed1","original_commit_id":"4e8007fca3e61ced9a4a4570957ab1f3d65441e5","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The vault_authority PDA is not properly validated with seeds constraints. The account should have `seeds = [b\"witness_rewards_vault_authority\"], bump` constraint like other PDA accounts in this program (e.g., config at line 341) and in other programs in the codebase (e.g., ddns_domain_rewards/src/lib.rs:352). Without this constraint, an attacker could pass an arbitrary account as vault_authority, potentially bypassing token account ownership validation.\n```suggestion\n    /// CHECK: PDA authority for reward vault transfers.\n    #[account(\n        seeds = [b\"witness_rewards_vault_authority\"],\n        bump\n    )]\n```","created_at":"2026-02-18T19:43:01Z","updated_at":"2026-02-18T19:43:04Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127609","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127609"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127609"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127609/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":354,"original_line":354,"side":"RIGHT","author_association":"NONE","original_position":354,"position":354,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127646","pull_request_review_id":3821872617,"id":2824127646,"node_id":"PRRC_kwDORKbd9s6oVMSe","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"AVsmrpWUMLsdaHr5Y8p2N96fBMPTHVV7WLz8iiu4nBge\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }\n+\n+        let remaining_epoch_budget = cfg\n+            .max_reward_per_epoch\n+            .saturating_sub(epoch_state.total_accrued_rewards);\n+        let delta_capped = delta_reward.min(remaining_epoch_budget);\n+\n+        stats.submitted_receipts = stats.submitted_receipts.saturating_add(receipt_count);\n+        stats.rewardable_receipts = stats.rewardable_receipts.saturating_add(rewardable);\n+        stats.unique_name_hashes = stats.unique_name_hashes.saturating_add(unique_name_hashes);\n+        stats.unique_colos = stats.unique_colos.saturating_add(unique_colos);\n+        stats.earned_reward = stats.earned_reward.saturating_add(delta_capped);\n+        stats.last_receipts_root = receipts_root;\n+        stats.last_submission_slot = now_slot;\n+\n+        epoch_state.total_submitted_receipts = epoch_state.total_submitted_receipts.saturating_add(receipt_count as u64);\n+        epoch_state.total_rewardable_receipts = epoch_state.total_rewardable_receipts.saturating_add(rewardable as u64);\n+        epoch_state.total_accrued_rewards = epoch_state.total_accrued_rewards.saturating_add(delta_capped);\n+\n+        emit!(BatchSubmitted {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            receipts_root,\n+            receipt_count,\n+            rewardable_receipts: rewardable,\n+            delta_reward: delta_capped,\n+            diversity_bonus_bps,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn claim_rewards(ctx: Context<ClaimRewards>, epoch_id: u64) -> Result<()> {\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+        require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        require!(stats.earned_reward > 0, WitnessRewardsError::NothingToClaim);\n+\n+        let amount = stats.earned_reward;\n+        let cfg = &ctx.accounts.config;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.miner_toll_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.miner.key(),\n+        )?;\n+\n+        let signer_seeds: &[&[u8]] =\n+            &[b\"witness_rewards_vault_authority\", &[cfg.vault_authority_bump]];\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.miner_toll_ata.key(),\n+            &ctx.accounts.vault_authority.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke_signed(\n+            &ix,\n+            &[\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.miner_toll_ata.to_account_info(),\n+                ctx.accounts.vault_authority.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+            &[signer_seeds],\n+        )?;\n+\n+        stats.claimed = true;\n+        emit!(RewardsClaimed {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            amount,\n+        });\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    /// CHECK: validated as SPL mint in instruction.\n+    pub toll_mint: UncheckedAccount<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + WitnessRewardsConfig::SIZE,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA authority for reward vault transfers.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated as SPL token account in instruction.\n+    #[account(mut)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"c3b5deeda9c82841a7332fc68f59772031771ed1","original_commit_id":"4e8007fca3e61ced9a4a4570957ab1f3d65441e5","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The InitConfig accounts struct is missing a rent sysvar field. All other init instructions in the codebase (ddns_domain_rewards, ddns_miner_score, ddns_ns_incentives, ddns_operators, ddns_rewards, ddns_stake, ddns_stake_gov) include `pub rent: Sysvar<'info, Rent>` in their init account structs. The CLI script passes this account (line 211 in witness_rewards.ts), but the program doesn't expect it, which will cause a runtime account mismatch error.\n```suggestion\n    pub token_program: UncheckedAccount<'info>,\n    pub rent: Sysvar<'info, Rent>,\n```","created_at":"2026-02-18T19:43:01Z","updated_at":"2026-02-18T19:43:04Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127646","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127646"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127646"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127646/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":319,"original_line":319,"side":"RIGHT","author_association":"NONE","original_position":319,"position":319,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127668","pull_request_review_id":3821872617,"id":2824127668,"node_id":"PRRC_kwDORKbd9s6oVMS0","diff_hunk":"@@ -0,0 +1,469 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import { fileURLToPath } from \"node:url\";\n+import crypto from \"node:crypto\";\n+import * as anchor from \"@coral-xyz/anchor\";\n+import { BorshAccountsCoder, type Idl } from \"@coral-xyz/anchor\";\n+import { Connection, Keypair, PublicKey, SystemProgram } from \"@solana/web3.js\";\n+import BN from \"bn.js\";\n+import yargs from \"yargs\";\n+import { hideBin } from \"yargs/helpers\";\n+import {\n+  TOKEN_PROGRAM_ID,\n+    createAssociatedTokenAccount,\n+  createMint,\n+  getAssociatedTokenAddressSync,\n+  getOrCreateAssociatedTokenAccount,\n+  mintTo,\n+} from \"@solana/spl-token\";\n+\n+const DEFAULT_RPC =\n+  process.env.ANCHOR_PROVIDER_URL || process.env.SOLANA_RPC_URL || \"https://api.devnet.solana.com\";\n+const DEFAULT_WALLET =\n+  process.env.ANCHOR_WALLET || path.join(process.env.HOME || \".\", \".config/solana/id.json\");\n+const DEFAULT_PROGRAM_ID =\n+  process.env.DDNS_WITNESS_REWARDS_PROGRAM_ID || \"AVsmrpWUMLsdaHr5Y8p2N96fBMPTHVV7WLz8iiu4nBge\";\n+\n+function u64Le(value: bigint): Buffer {\n+  const b = Buffer.alloc(8);\n+  b.writeBigUInt64LE(value);\n+  return b;\n+}\n+\n+function loadKeypair(filePath: string): Keypair {\n+  const raw = JSON.parse(fs.readFileSync(filePath, \"utf8\"));\n+  return Keypair.fromSecretKey(Uint8Array.from(raw));\n+}\n+\n+function loadIdl(): Idl {\n+  const solanaDir = path.resolve(path.dirname(fileURLToPath(import.meta.url)), \"..\");\n+  const p = path.join(solanaDir, \"target\", \"idl\", \"ddns_witness_rewards.json\");\n+  if (!fs.existsSync(p)) {\n+    throw new Error(`missing_idl:${p}. Run: anchor build --program-name ddns_witness_rewards`);\n+  }\n+  const idl = JSON.parse(fs.readFileSync(p, \"utf8\")) as any;\n+\n+  // Anchor 0.32 can emit IDLs where `accounts[]` only have name+discriminator and the struct\n+  // type lives in `types[]`. Anchor TS expects `accounts[].type` to exist for account clients.\n+  if (Array.isArray(idl.accounts) && Array.isArray(idl.types)) {\n+    const byName = new Map<string, any>();\n+    for (const t of idl.types) byName.set(t.name, t.type);\n+    for (const a of idl.accounts) {\n+      if (!a.type) {\n+        const t = byName.get(a.name);\n+        if (t) a.type = t;\n+      }\n+    }\n+  }\n+\n+  // Provide sizes for Anchor TS account clients (8-byte discriminator + fixed struct sizes).\n+  const accountSizes: Record<string, number> = {\n+    WitnessRewardsConfig: 8 + 143,\n+    MinerBond: 8 + 49,\n+    EpochMinerStats: 8 + 104,\n+    EpochState: 8 + 33,\n+  };\n+  if (Array.isArray(idl.accounts)) {\n+    for (const a of idl.accounts) {\n+      if (a.size == null && typeof a.name === \"string\" && accountSizes[a.name] != null) {\n+        a.size = accountSizes[a.name];\n+      }\n+    }\n+  }\n+\n+  return idl as Idl;\n+}\n+\n+function readProgramIdFromAnchorToml(rpcUrl: string): string | null {\n+  try {\n+    const tomlPath = path.resolve(\"Anchor.toml\");\n+    if (!fs.existsSync(tomlPath)) return null;\n+    const content = fs.readFileSync(tomlPath, \"utf8\");\n+    const isLocal = /127\\\\.0\\\\.0\\\\.1|localhost/.test(rpcUrl);\n+    const section = isLocal ? \"programs.localnet\" : \"programs.devnet\";\n+    const re = new RegExp(`\\\\\\\\[${section}\\\\\\\\][^\\\\\\\\[]*?ddns_witness_rewards\\\\\\\\s*=\\\\\\\\s*\\\\\\\"([^\\\\\\\"]+)\\\\\\\"`, \"s\");\n+    const match = content.match(re);\n+    return match ? match[1] : null;\n+  } catch {\n+    return null;\n+  }\n+}\n+\n+async function fetchDecoded(\n+  connection: Connection,\n+  coder: BorshAccountsCoder,\n+  pubkey: PublicKey,\n+  accountName: string\n+): Promise<any | null> {\n+  const info = await connection.getAccountInfo(pubkey);\n+  if (!info) return null;\n+  return coder.decode(accountName, info.data);\n+}\n+\n+function requireHex32(name: string, hex: string): Uint8Array {\n+  const h = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n+  if (!/^[0-9a-fA-F]{64}$/.test(h)) throw new Error(`${name}_must_be_32_byte_hex`);\n+  return Uint8Array.from(Buffer.from(h, \"hex\"));\n+}\n+\n+function derivePdas(programId: PublicKey, miner: PublicKey, epochId?: bigint) {\n+  const [config] = PublicKey.findProgramAddressSync([Buffer.from(\"witness_rewards_config\")], programId);\n+  const [vaultAuthority] = PublicKey.findProgramAddressSync([Buffer.from(\"witness_rewards_vault_authority\")], programId);\n+  const [bond] = PublicKey.findProgramAddressSync([Buffer.from(\"bond\"), miner.toBuffer()], programId);\n+\n+  let epochState: PublicKey | null = null;\n+  let epochStats: PublicKey | null = null;\n+  if (epochId !== undefined) {\n+    const seed = u64Le(epochId);\n+    epochState = PublicKey.findProgramAddressSync([Buffer.from(\"epoch_state\"), seed], programId)[0];\n+    epochStats = PublicKey.findProgramAddressSync([Buffer.from(\"epoch_stats\"), seed, miner.toBuffer()], programId)[0];\n+  }\n+  return { config, vaultAuthority, bond, epochState, epochStats };\n+}\n+\n+async function loadProgram(opts: { rpc: string; walletPath: string; programId: string }) {\n+  const payer = loadKeypair(opts.walletPath);\n+  const connection = new Connection(opts.rpc, \"confirmed\");\n+  const provider = new anchor.AnchorProvider(connection, new anchor.Wallet(payer), { commitment: \"confirmed\" });\n+  anchor.setProvider(provider);\n+\n+  const idl = loadIdl();\n+  const coder = new BorshAccountsCoder(idl);\n+  const programId = new PublicKey(opts.programId);\n+  const program = new anchor.Program(idl as any, provider);","path":"solana/scripts/witness_rewards.ts","commit_id":"c3b5deeda9c82841a7332fc68f59772031771ed1","original_commit_id":"4e8007fca3e61ced9a4a4570957ab1f3d65441e5","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The Program constructor is missing the programId parameter. The call should be `new anchor.Program(idl as any, programId, provider)` to match the Anchor 0.32 API. Without the programId, the program will not be able to derive the correct addresses or make calls to the deployed program. This pattern is used correctly in other scripts such as miner_score.ts (line 144).\n```suggestion\n  const program = new anchor.Program(idl as any, programId, provider);\n```","created_at":"2026-02-18T19:43:02Z","updated_at":"2026-02-18T19:43:05Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127668","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127668"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127668"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127668/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":133,"original_line":133,"side":"RIGHT","author_association":"NONE","original_position":133,"position":133,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127772","pull_request_review_id":3821872617,"id":2824127772,"node_id":"PRRC_kwDORKbd9s6oVMUc","diff_hunk":"@@ -0,0 +1,469 @@\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import { fileURLToPath } from \"node:url\";\n+import crypto from \"node:crypto\";","path":"solana/scripts/witness_rewards.ts","commit_id":"c3b5deeda9c82841a7332fc68f59772031771ed1","original_commit_id":"4e8007fca3e61ced9a4a4570957ab1f3d65441e5","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The crypto module is imported but never used in the file. This import can be removed.\n```suggestion\n\n```","created_at":"2026-02-18T19:43:03Z","updated_at":"2026-02-18T19:43:05Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127772","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127772"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127772"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127772/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":4,"original_line":4,"side":"RIGHT","author_association":"NONE","original_position":4,"position":4,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127795","pull_request_review_id":3821872617,"id":2824127795,"node_id":"PRRC_kwDORKbd9s6oVMUz","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"AVsmrpWUMLsdaHr5Y8p2N96fBMPTHVV7WLz8iiu4nBge\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }\n+\n+        let remaining_epoch_budget = cfg\n+            .max_reward_per_epoch\n+            .saturating_sub(epoch_state.total_accrued_rewards);\n+        let delta_capped = delta_reward.min(remaining_epoch_budget);\n+\n+        stats.submitted_receipts = stats.submitted_receipts.saturating_add(receipt_count);\n+        stats.rewardable_receipts = stats.rewardable_receipts.saturating_add(rewardable);\n+        stats.unique_name_hashes = stats.unique_name_hashes.saturating_add(unique_name_hashes);\n+        stats.unique_colos = stats.unique_colos.saturating_add(unique_colos);\n+        stats.earned_reward = stats.earned_reward.saturating_add(delta_capped);\n+        stats.last_receipts_root = receipts_root;\n+        stats.last_submission_slot = now_slot;\n+\n+        epoch_state.total_submitted_receipts = epoch_state.total_submitted_receipts.saturating_add(receipt_count as u64);\n+        epoch_state.total_rewardable_receipts = epoch_state.total_rewardable_receipts.saturating_add(rewardable as u64);\n+        epoch_state.total_accrued_rewards = epoch_state.total_accrued_rewards.saturating_add(delta_capped);\n+\n+        emit!(BatchSubmitted {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            receipts_root,\n+            receipt_count,\n+            rewardable_receipts: rewardable,\n+            delta_reward: delta_capped,\n+            diversity_bonus_bps,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn claim_rewards(ctx: Context<ClaimRewards>, epoch_id: u64) -> Result<()> {\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+        require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        require!(stats.earned_reward > 0, WitnessRewardsError::NothingToClaim);\n+\n+        let amount = stats.earned_reward;\n+        let cfg = &ctx.accounts.config;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.miner_toll_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.miner.key(),\n+        )?;\n+\n+        let signer_seeds: &[&[u8]] =\n+            &[b\"witness_rewards_vault_authority\", &[cfg.vault_authority_bump]];\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.miner_toll_ata.key(),\n+            &ctx.accounts.vault_authority.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke_signed(\n+            &ix,\n+            &[\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.miner_toll_ata.to_account_info(),\n+                ctx.accounts.vault_authority.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+            &[signer_seeds],\n+        )?;\n+\n+        stats.claimed = true;\n+        emit!(RewardsClaimed {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            amount,\n+        });\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    /// CHECK: validated as SPL mint in instruction.\n+    pub toll_mint: UncheckedAccount<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + WitnessRewardsConfig::SIZE,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA authority for reward vault transfers.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated as SPL token account in instruction.\n+    #[account(mut)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+        has_one = authority @ WitnessRewardsError::Unauthorized,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct FundRewardVault<'info> {\n+    #[account(mut)]\n+    pub funder: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub funder_ata: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    /// CHECK: PDA checked in instruction.\n+    pub vault_authority: UncheckedAccount<'info>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct DepositBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerBond::SIZE,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct WithdrawBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ WitnessRewardsError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+}\n+\n+#[derive(Accounts)]\n+#[instruction(epoch_id: u64)]\n+pub struct SubmitReceiptBatch<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ WitnessRewardsError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + EpochMinerStats::SIZE,\n+        seeds = [b\"epoch_stats\".as_ref(), &epoch_id.to_le_bytes(), miner.key().as_ref()],\n+        bump\n+    )]\n+    pub epoch_stats: Account<'info, EpochMinerStats>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + EpochState::SIZE,\n+        seeds = [b\"epoch_state\".as_ref(), &epoch_id.to_le_bytes()],\n+        bump\n+    )]\n+    pub epoch_state: Account<'info, EpochState>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+#[instruction(epoch_id: u64)]\n+pub struct ClaimRewards<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA signer.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump = config.vault_authority_bump,\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"epoch_stats\", &epoch_id.to_le_bytes(), miner.key().as_ref()],\n+        bump = epoch_stats.bump,\n+    )]\n+    pub epoch_stats: Account<'info, EpochMinerStats>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub miner_toll_ata: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+}\n+\n+#[account]\n+pub struct WitnessRewardsConfig {\n+    pub authority: Pubkey,\n+    pub toll_mint: Pubkey,\n+    pub reward_vault: Pubkey,\n+    pub vault_authority_bump: u8,\n+    pub epoch_len_slots: u64,\n+    pub max_reward_per_epoch: u64,\n+    pub min_bond_lamports: u64,\n+    pub reward_per_receipt: u64,\n+    pub max_rewardable_receipts_per_miner_per_epoch: u32,\n+    pub cooldown_slots: u64,\n+    pub enabled: bool,\n+    pub bump: u8,\n+}\n+\n+impl WitnessRewardsConfig {\n+    pub const SIZE: usize = 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 4 + 8 + 1 + 1;\n+}\n+\n+#[account]\n+pub struct MinerBond {\n+    pub miner: Pubkey,\n+    pub bond_lamports: u64,\n+    pub last_action_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl MinerBond {\n+    pub const SIZE: usize = 32 + 8 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct EpochMinerStats {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub rewardable_receipts: u32,\n+    pub submitted_receipts: u32,\n+    pub unique_name_hashes: u32,\n+    pub unique_colos: u16,\n+    pub earned_reward: u64,\n+    pub claimed: bool,\n+    pub last_receipts_root: [u8; 32],\n+    pub last_submission_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl EpochMinerStats {\n+    pub const SIZE: usize = 8 + 32 + 4 + 4 + 4 + 2 + 8 + 1 + 32 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct EpochState {\n+    pub epoch_id: u64,\n+    pub total_submitted_receipts: u64,\n+    pub total_rewardable_receipts: u64,\n+    pub total_accrued_rewards: u64,\n+    pub bump: u8,\n+}\n+\n+impl EpochState {\n+    pub const SIZE: usize = 8 + 8 + 8 + 8 + 1;\n+}\n+\n+#[event]\n+pub struct BatchSubmitted {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub receipts_root: [u8; 32],\n+    pub receipt_count: u32,\n+    pub rewardable_receipts: u32,\n+    pub delta_reward: u64,\n+    pub diversity_bonus_bps: u16,\n+}\n+\n+#[event]\n+pub struct RewardsClaimed {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub amount: u64,\n+}\n+\n+#[error_code]\n+pub enum WitnessRewardsError {\n+    #[msg(\"Invalid config\")]\n+    InvalidConfig,\n+    #[msg(\"Unauthorized\")]\n+    Unauthorized,\n+    #[msg(\"Invalid amount\")]\n+    InvalidAmount,\n+    #[msg(\"Math overflow\")]\n+    MathOverflow,\n+    #[msg(\"Program disabled\")]\n+    Disabled,\n+    #[msg(\"Insufficient bond\")]\n+    InsufficientBond,\n+    #[msg(\"Bad epoch\")]\n+    BadEpoch,\n+    #[msg(\"Invalid miner\")]\n+    InvalidMiner,\n+    #[msg(\"Duplicate receipts root\")]\n+    DuplicateRoot,\n+    #[msg(\"Already claimed\")]\n+    AlreadyClaimed,\n+    #[msg(\"Nothing to claim\")]\n+    NothingToClaim,\n+    #[msg(\"Invalid mint\")]\n+    InvalidMint,\n+    #[msg(\"Invalid vault authority\")]\n+    InvalidVaultAuthority,\n+    #[msg(\"Invalid vault\")]\n+    InvalidVault,\n+    #[msg(\"Bond cooldown not met\")]\n+    CooldownNotMet,\n+    #[msg(\"Bond withdrawal would violate rent-exemption\")]\n+    BondRentViolation,\n+}\n+\n+fn compute_diversity_bonus_bps(unique_name_hashes: u32, unique_colos: u16) -> u16 {\n+    let name_bonus = unique_name_hashes.saturating_mul(10); // 0.1% per unique name\n+    let colo_bonus = (unique_colos as u32).saturating_mul(100); // 1% per colo\n+    (name_bonus.saturating_add(colo_bonus) as u16).min(MAX_DIVERSITY_BONUS_BPS)\n+}\n+\n+fn validate_mint_account(\n+    ai: &AccountInfo<'_>,\n+    token_program: &Pubkey,\n+) -> Result<spl_token::state::Mint> {\n+    require_keys_eq!(*ai.owner, *token_program, WitnessRewardsError::InvalidMint);\n+    spl_token::state::Mint::unpack(&ai.data.borrow())\n+        .map_err(|_| error!(WitnessRewardsError::InvalidMint))\n+}\n+\n+fn validate_token_account(\n+    ai: &AccountInfo<'_>,\n+    token_program: &Pubkey,\n+    expected_mint: &Pubkey,\n+    expected_owner: &Pubkey,\n+) -> Result<spl_token::state::Account> {\n+    require_keys_eq!(*ai.owner, *token_program, WitnessRewardsError::InvalidVault);\n+    let parsed = spl_token::state::Account::unpack(&ai.data.borrow())\n+        .map_err(|_| error!(WitnessRewardsError::InvalidVault))?;\n+    require_keys_eq!(parsed.mint, *expected_mint, WitnessRewardsError::InvalidMint);\n+    require_keys_eq!(parsed.owner, *expected_owner, WitnessRewardsError::InvalidVaultAuthority);\n+    Ok(parsed)\n+}","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"c3b5deeda9c82841a7332fc68f59772031771ed1","original_commit_id":"4e8007fca3e61ced9a4a4570957ab1f3d65441e5","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The ddns_witness_rewards program lacks automated test coverage. All other programs in the codebase have test files in solana/tests/ (e.g., ddns_miner_score.ts, ddns_domain_rewards.ts, ddns_operators.ts, etc.). A test file should be added to verify the program's instructions work correctly, especially for bond deposits, batch submissions, and reward claims.\n```suggestion\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_compute_diversity_bonus_bps_basic() {\n        // 5 unique name hashes -> 5 * 10 = 50 bps (0.5%)\n        // 2 unique colos -> 2 * 100 = 200 bps (2.0%)\n        // total = 250 bps (2.5%)\n        let bonus = compute_diversity_bonus_bps(5, 2);\n        assert_eq!(bonus, 250);\n    }\n\n    #[test]\n    fn test_compute_diversity_bonus_bps_caps_at_max() {\n        // Use large inputs that would exceed the maximum if uncapped.\n        let bonus = compute_diversity_bonus_bps(10_000, 1_000);\n        assert_eq!(bonus, MAX_DIVERSITY_BONUS_BPS);\n    }\n}\n```","created_at":"2026-02-18T19:43:03Z","updated_at":"2026-02-18T19:43:03Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127795","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127795"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/69#discussion_r2824127795"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/69"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2824127795/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":610,"original_line":610,"side":"RIGHT","author_association":"NONE","original_position":610,"position":610,"subject_type":"line"}]