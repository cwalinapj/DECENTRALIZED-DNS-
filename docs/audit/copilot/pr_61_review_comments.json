[{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235001","pull_request_review_id":3818691840,"id":2821235001,"node_id":"PRRC_kwDORKbd9s6oKKE5","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"HTd88EzMhvsWjNwMnrt6mquChgogjmdQTbSmDzwps975\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"ef65e1974240a7dc34d317b6b4ae9f9fc4c0622a","original_commit_id":"cb9525550ac942cc1d9bd4712810c2e02c9bdc4f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The init_config function expects vault_authority and reward_vault to be provided as pre-existing accounts, but does not create them. This deviates from the established pattern in other Solana programs in this repository (ddns_stake, ddns_rewards, ddns_miner_score) which create both the vault_authority PDA as a 0-data system account and the reward_vault as an SPL token account during initialization using create_account and initialize_account CPIs. This inconsistency creates operational risk: the caller must manually create these accounts off-chain with exact specifications, and any misconfiguration could lead to loss of funds or inability to use the program. Consider following the established pattern of creating both accounts within init_config to ensure correct setup and reduce deployment complexity.","created_at":"2026-02-18T09:21:22Z","updated_at":"2026-02-18T09:21:25Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235001","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235001"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235001"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235001/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":13,"original_start_line":13,"start_side":"RIGHT","line":50,"original_line":50,"side":"RIGHT","author_association":"NONE","original_position":50,"position":50,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235038","pull_request_review_id":3818691840,"id":2821235038,"node_id":"PRRC_kwDORKbd9s6oKKFe","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"HTd88EzMhvsWjNwMnrt6mquChgogjmdQTbSmDzwps975\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }\n+\n+        let remaining_epoch_budget = cfg\n+            .max_reward_per_epoch\n+            .saturating_sub(epoch_state.total_accrued_rewards);\n+        let delta_capped = delta_reward.min(remaining_epoch_budget);\n+\n+        stats.submitted_receipts = stats.submitted_receipts.saturating_add(receipt_count);\n+        stats.rewardable_receipts = stats.rewardable_receipts.saturating_add(rewardable);\n+        stats.unique_name_hashes = stats.unique_name_hashes.saturating_add(unique_name_hashes);\n+        stats.unique_colos = stats.unique_colos.saturating_add(unique_colos);\n+        stats.earned_reward = stats.earned_reward.saturating_add(delta_capped);\n+        stats.last_receipts_root = receipts_root;\n+        stats.last_submission_slot = now_slot;\n+\n+        epoch_state.total_submitted_receipts = epoch_state.total_submitted_receipts.saturating_add(receipt_count as u64);\n+        epoch_state.total_rewardable_receipts = epoch_state.total_rewardable_receipts.saturating_add(rewardable as u64);\n+        epoch_state.total_accrued_rewards = epoch_state.total_accrued_rewards.saturating_add(delta_capped);\n+\n+        emit!(BatchSubmitted {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            receipts_root,\n+            receipt_count,\n+            rewardable_receipts: rewardable,\n+            delta_reward: delta_capped,\n+            diversity_bonus_bps,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn claim_rewards(ctx: Context<ClaimRewards>, epoch_id: u64) -> Result<()> {\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+        require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        require!(stats.earned_reward > 0, WitnessRewardsError::NothingToClaim);\n+\n+        let amount = stats.earned_reward;\n+        let cfg = &ctx.accounts.config;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.miner_toll_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.miner.key(),\n+        )?;\n+\n+        let signer_seeds: &[&[u8]] =\n+            &[b\"witness_rewards_vault_authority\", &[cfg.vault_authority_bump]];\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.miner_toll_ata.key(),\n+            &ctx.accounts.vault_authority.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke_signed(\n+            &ix,\n+            &[\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.miner_toll_ata.to_account_info(),\n+                ctx.accounts.vault_authority.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+            &[signer_seeds],\n+        )?;\n+\n+        stats.claimed = true;\n+        emit!(RewardsClaimed {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            amount,\n+        });\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    /// CHECK: validated as SPL mint in instruction.\n+    pub toll_mint: UncheckedAccount<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + WitnessRewardsConfig::SIZE,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA authority for reward vault transfers.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated as SPL token account in instruction.\n+    #[account(mut)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+        has_one = authority @ WitnessRewardsError::Unauthorized,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct FundRewardVault<'info> {\n+    #[account(mut)]\n+    pub funder: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub funder_ata: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    /// CHECK: PDA checked in instruction.\n+    pub vault_authority: UncheckedAccount<'info>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct DepositBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + MinerBond::SIZE,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct WithdrawBond<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ WitnessRewardsError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+}\n+\n+#[derive(Accounts)]\n+#[instruction(epoch_id: u64)]\n+pub struct SubmitReceiptBatch<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    #[account(\n+        mut,\n+        seeds = [b\"bond\", miner.key().as_ref()],\n+        bump = bond.bump,\n+        constraint = bond.miner == miner.key() @ WitnessRewardsError::InvalidMiner,\n+    )]\n+    pub bond: Account<'info, MinerBond>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + EpochMinerStats::SIZE,\n+        seeds = [b\"epoch_stats\".as_ref(), &epoch_id.to_le_bytes(), miner.key().as_ref()],\n+        bump\n+    )]\n+    pub epoch_stats: Account<'info, EpochMinerStats>,\n+    #[account(\n+        init_if_needed,\n+        payer = miner,\n+        space = 8 + EpochState::SIZE,\n+        seeds = [b\"epoch_state\".as_ref(), &epoch_id.to_le_bytes()],\n+        bump\n+    )]\n+    pub epoch_state: Account<'info, EpochState>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+#[instruction(epoch_id: u64)]\n+pub struct ClaimRewards<'info> {\n+    #[account(mut)]\n+    pub miner: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA signer.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump = config.vault_authority_bump,\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"epoch_stats\", &epoch_id.to_le_bytes(), miner.key().as_ref()],\n+        bump = epoch_stats.bump,\n+    )]\n+    pub epoch_stats: Account<'info, EpochMinerStats>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub miner_toll_ata: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+}\n+\n+#[account]\n+pub struct WitnessRewardsConfig {\n+    pub authority: Pubkey,\n+    pub toll_mint: Pubkey,\n+    pub reward_vault: Pubkey,\n+    pub vault_authority_bump: u8,\n+    pub epoch_len_slots: u64,\n+    pub max_reward_per_epoch: u64,\n+    pub min_bond_lamports: u64,\n+    pub reward_per_receipt: u64,\n+    pub max_rewardable_receipts_per_miner_per_epoch: u32,\n+    pub cooldown_slots: u64,\n+    pub enabled: bool,\n+    pub bump: u8,\n+}\n+\n+impl WitnessRewardsConfig {\n+    pub const SIZE: usize = 32 + 32 + 32 + 1 + 8 + 8 + 8 + 8 + 4 + 8 + 1 + 1;\n+}\n+\n+#[account]\n+pub struct MinerBond {\n+    pub miner: Pubkey,\n+    pub bond_lamports: u64,\n+    pub last_action_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl MinerBond {\n+    pub const SIZE: usize = 32 + 8 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct EpochMinerStats {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub rewardable_receipts: u32,\n+    pub submitted_receipts: u32,\n+    pub unique_name_hashes: u32,\n+    pub unique_colos: u16,\n+    pub earned_reward: u64,\n+    pub claimed: bool,\n+    pub last_receipts_root: [u8; 32],\n+    pub last_submission_slot: u64,\n+    pub bump: u8,\n+}\n+\n+impl EpochMinerStats {\n+    pub const SIZE: usize = 8 + 32 + 4 + 4 + 4 + 2 + 8 + 1 + 32 + 8 + 1;\n+}\n+\n+#[account]\n+pub struct EpochState {\n+    pub epoch_id: u64,\n+    pub total_submitted_receipts: u64,\n+    pub total_rewardable_receipts: u64,\n+    pub total_accrued_rewards: u64,\n+    pub bump: u8,\n+}\n+\n+impl EpochState {\n+    pub const SIZE: usize = 8 + 8 + 8 + 8 + 1;\n+}\n+\n+#[event]\n+pub struct BatchSubmitted {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub receipts_root: [u8; 32],\n+    pub receipt_count: u32,\n+    pub rewardable_receipts: u32,\n+    pub delta_reward: u64,\n+    pub diversity_bonus_bps: u16,\n+}\n+\n+#[event]\n+pub struct RewardsClaimed {\n+    pub epoch_id: u64,\n+    pub miner: Pubkey,\n+    pub amount: u64,\n+}\n+\n+#[error_code]\n+pub enum WitnessRewardsError {\n+    #[msg(\"Invalid config\")]\n+    InvalidConfig,\n+    #[msg(\"Unauthorized\")]\n+    Unauthorized,\n+    #[msg(\"Invalid amount\")]\n+    InvalidAmount,\n+    #[msg(\"Math overflow\")]\n+    MathOverflow,\n+    #[msg(\"Program disabled\")]\n+    Disabled,\n+    #[msg(\"Insufficient bond\")]\n+    InsufficientBond,\n+    #[msg(\"Bad epoch\")]\n+    BadEpoch,\n+    #[msg(\"Invalid miner\")]\n+    InvalidMiner,\n+    #[msg(\"Duplicate receipts root\")]\n+    DuplicateRoot,\n+    #[msg(\"Already claimed\")]\n+    AlreadyClaimed,\n+    #[msg(\"Nothing to claim\")]\n+    NothingToClaim,\n+    #[msg(\"Invalid mint\")]\n+    InvalidMint,\n+    #[msg(\"Invalid vault authority\")]\n+    InvalidVaultAuthority,\n+    #[msg(\"Invalid vault\")]\n+    InvalidVault,\n+    #[msg(\"Bond cooldown not met\")]\n+    CooldownNotMet,\n+    #[msg(\"Bond withdrawal would violate rent-exemption\")]\n+    BondRentViolation,\n+}\n+\n+fn compute_diversity_bonus_bps(unique_name_hashes: u32, unique_colos: u16) -> u16 {\n+    let name_bonus = unique_name_hashes.saturating_mul(10); // 0.1% per unique name\n+    let colo_bonus = (unique_colos as u32).saturating_mul(100); // 1% per colo\n+    (name_bonus.saturating_add(colo_bonus) as u16).min(MAX_DIVERSITY_BONUS_BPS)","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"ef65e1974240a7dc34d317b6b4ae9f9fc4c0622a","original_commit_id":"cb9525550ac942cc1d9bd4712810c2e02c9bdc4f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The diversity bonus computation can silently truncate values when casting from u32 to u16. If unique_name_hashes is very large (e.g., 6554 or more), name_bonus will exceed u16::MAX (65535) and the cast will truncate/wrap. While the .min(MAX_DIVERSITY_BONUS_BPS) call limits the final result, the truncation happens before that check, potentially resulting in incorrect bonus calculations. Consider checking for overflow before the cast or using checked arithmetic with proper error handling to ensure bonus calculations are always correct.\n```suggestion\n    let total_bonus = name_bonus.saturating_add(colo_bonus);\n    let capped_bonus = total_bonus.min(u32::from(MAX_DIVERSITY_BONUS_BPS));\n    capped_bonus as u16\n```","created_at":"2026-02-18T09:21:23Z","updated_at":"2026-02-18T09:21:25Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235038","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235038"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235038"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235038/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":586,"original_line":586,"side":"RIGHT","author_association":"NONE","original_position":586,"position":586,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235073","pull_request_review_id":3818691840,"id":2821235073,"node_id":"PRRC_kwDORKbd9s6oKKGB","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"HTd88EzMhvsWjNwMnrt6mquChgogjmdQTbSmDzwps975\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"ef65e1974240a7dc34d317b6b4ae9f9fc4c0622a","original_commit_id":"cb9525550ac942cc1d9bd4712810c2e02c9bdc4f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The epoch_state initialization check uses epoch_id == 0 to detect if the account is newly created, but epoch_id 0 is a valid epoch (the first epoch). When init_if_needed creates a new account, all fields are zero-initialized. If a miner submits receipts for epoch 0, the code at line 204 will treat it as newly initialized even on subsequent submissions within epoch 0, potentially allowing the same epoch_id to be set multiple times and bypassing the validation at line 208. Consider using a separate boolean flag to track initialization status, or use a sentinel value like u64::MAX that cannot be a valid epoch_id.","created_at":"2026-02-18T09:21:23Z","updated_at":"2026-02-18T09:21:25Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235073","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235073"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235073"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235073/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":203,"original_start_line":203,"start_side":"RIGHT","line":209,"original_line":209,"side":"RIGHT","author_association":"NONE","original_position":209,"position":209,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235098","pull_request_review_id":3818691840,"id":2821235098,"node_id":"PRRC_kwDORKbd9s6oKKGa","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"HTd88EzMhvsWjNwMnrt6mquChgogjmdQTbSmDzwps975\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);\n+        let bonus_bps_total: u128 = (10_000u128)\n+            .checked_add(diversity_bonus_bps as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+\n+        let delta_reward: u64 = ((rewardable as u128)\n+            .checked_mul(cfg.reward_per_receipt as u128)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            .checked_mul(bonus_bps_total)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?\n+            / BPS_DENOM) as u64;\n+\n+        let epoch_state = &mut ctx.accounts.epoch_state;\n+        if epoch_state.epoch_id == 0 {\n+            epoch_state.epoch_id = epoch_id;\n+            epoch_state.bump = ctx.bumps.epoch_state;\n+        } else {\n+            require!(epoch_state.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        }\n+\n+        let remaining_epoch_budget = cfg\n+            .max_reward_per_epoch\n+            .saturating_sub(epoch_state.total_accrued_rewards);\n+        let delta_capped = delta_reward.min(remaining_epoch_budget);\n+\n+        stats.submitted_receipts = stats.submitted_receipts.saturating_add(receipt_count);\n+        stats.rewardable_receipts = stats.rewardable_receipts.saturating_add(rewardable);\n+        stats.unique_name_hashes = stats.unique_name_hashes.saturating_add(unique_name_hashes);\n+        stats.unique_colos = stats.unique_colos.saturating_add(unique_colos);\n+        stats.earned_reward = stats.earned_reward.saturating_add(delta_capped);\n+        stats.last_receipts_root = receipts_root;\n+        stats.last_submission_slot = now_slot;\n+\n+        epoch_state.total_submitted_receipts = epoch_state.total_submitted_receipts.saturating_add(receipt_count as u64);\n+        epoch_state.total_rewardable_receipts = epoch_state.total_rewardable_receipts.saturating_add(rewardable as u64);\n+        epoch_state.total_accrued_rewards = epoch_state.total_accrued_rewards.saturating_add(delta_capped);\n+\n+        emit!(BatchSubmitted {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            receipts_root,\n+            receipt_count,\n+            rewardable_receipts: rewardable,\n+            delta_reward: delta_capped,\n+            diversity_bonus_bps,\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn claim_rewards(ctx: Context<ClaimRewards>, epoch_id: u64) -> Result<()> {\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+        require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+        require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        require!(stats.earned_reward > 0, WitnessRewardsError::NothingToClaim);\n+\n+        let amount = stats.earned_reward;\n+        let cfg = &ctx.accounts.config;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.miner_toll_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.miner.key(),\n+        )?;\n+\n+        let signer_seeds: &[&[u8]] =\n+            &[b\"witness_rewards_vault_authority\", &[cfg.vault_authority_bump]];\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.miner_toll_ata.key(),\n+            &ctx.accounts.vault_authority.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke_signed(\n+            &ix,\n+            &[\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.miner_toll_ata.to_account_info(),\n+                ctx.accounts.vault_authority.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+            &[signer_seeds],\n+        )?;\n+\n+        stats.claimed = true;\n+        emit!(RewardsClaimed {\n+            epoch_id,\n+            miner: ctx.accounts.miner.key(),\n+            amount,\n+        });\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Accounts)]\n+pub struct InitConfig<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    /// CHECK: validated as SPL mint in instruction.\n+    pub toll_mint: UncheckedAccount<'info>,\n+    #[account(\n+        init,\n+        payer = authority,\n+        space = 8 + WitnessRewardsConfig::SIZE,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: PDA authority for reward vault transfers.\n+    #[account(\n+        seeds = [b\"witness_rewards_vault_authority\"],\n+        bump\n+    )]\n+    pub vault_authority: UncheckedAccount<'info>,\n+    /// CHECK: validated as SPL token account in instruction.\n+    #[account(mut)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    pub system_program: Program<'info, System>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct SetEnabled<'info> {\n+    #[account(mut)]\n+    pub authority: Signer<'info>,\n+    #[account(\n+        mut,\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+        has_one = authority @ WitnessRewardsError::Unauthorized,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+}\n+\n+#[derive(Accounts)]\n+pub struct FundRewardVault<'info> {\n+    #[account(mut)]\n+    pub funder: Signer<'info>,\n+    #[account(\n+        seeds = [b\"witness_rewards_config\"],\n+        bump = config.bump,\n+    )]\n+    pub config: Account<'info, WitnessRewardsConfig>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut)]\n+    pub funder_ata: UncheckedAccount<'info>,\n+    /// CHECK: validated in instruction.\n+    #[account(mut, address = config.reward_vault @ WitnessRewardsError::InvalidVault)]\n+    pub reward_vault: UncheckedAccount<'info>,\n+    /// CHECK: address checked.\n+    #[account(address = spl_token::ID)]\n+    pub token_program: UncheckedAccount<'info>,\n+    /// CHECK: PDA checked in instruction.","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"ef65e1974240a7dc34d317b6b4ae9f9fc4c0622a","original_commit_id":"cb9525550ac942cc1d9bd4712810c2e02c9bdc4f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The vault_authority account in FundRewardVault is not validated to be the correct PDA. While validate_token_account checks that reward_vault is owned by vault_authority, there's no constraint verifying that vault_authority itself is the expected PDA with seeds [b\"witness_rewards_vault_authority\"]. A malicious actor could pass a different account as vault_authority along with a token account owned by that account, bypassing the intended vault checks. Add PDA validation constraints similar to those in ClaimRewards (lines 444-445) to ensure vault_authority matches the expected PDA.\n```suggestion\n    /// CHECK: PDA authority for reward vault transfers.\n    #[account(\n        seeds = [b\"witness_rewards_vault_authority\"],\n        bump\n    )]\n```","created_at":"2026-02-18T09:21:23Z","updated_at":"2026-02-18T09:21:25Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235098","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235098"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235098"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235098/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":354,"original_line":354,"side":"RIGHT","author_association":"NONE","original_position":354,"position":354,"subject_type":"line"},{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235116","pull_request_review_id":3818691840,"id":2821235116,"node_id":"PRRC_kwDORKbd9s6oKKGs","diff_hunk":"@@ -0,0 +1,610 @@\n+use anchor_lang::prelude::*;\n+use anchor_lang::solana_program::{program::invoke, program::invoke_signed, program_pack::Pack};\n+\n+declare_id!(\"HTd88EzMhvsWjNwMnrt6mquChgogjmdQTbSmDzwps975\");\n+\n+const BPS_DENOM: u128 = 10_000;\n+const MAX_DIVERSITY_BONUS_BPS: u16 = 2_000; // +20%\n+\n+#[program]\n+pub mod ddns_witness_rewards {\n+    use super::*;\n+\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn init_config(\n+        ctx: Context<InitConfig>,\n+        epoch_len_slots: u64,\n+        max_reward_per_epoch: u64,\n+        min_bond_lamports: u64,\n+        reward_per_receipt: u64,\n+        max_rewardable_receipts_per_miner_per_epoch: u32,\n+        cooldown_slots: u64,\n+        enabled: bool,\n+    ) -> Result<()> {\n+        require!(epoch_len_slots > 0, WitnessRewardsError::InvalidConfig);\n+        validate_mint_account(\n+            &ctx.accounts.toll_mint.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.toll_mint.key(),\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let cfg = &mut ctx.accounts.config;\n+        cfg.authority = ctx.accounts.authority.key();\n+        cfg.toll_mint = ctx.accounts.toll_mint.key();\n+        cfg.reward_vault = ctx.accounts.reward_vault.key();\n+        cfg.vault_authority_bump = ctx.bumps.vault_authority;\n+        cfg.epoch_len_slots = epoch_len_slots;\n+        cfg.max_reward_per_epoch = max_reward_per_epoch;\n+        cfg.min_bond_lamports = min_bond_lamports;\n+        cfg.reward_per_receipt = reward_per_receipt;\n+        cfg.max_rewardable_receipts_per_miner_per_epoch = max_rewardable_receipts_per_miner_per_epoch;\n+        cfg.cooldown_slots = cooldown_slots;\n+        cfg.enabled = enabled;\n+        cfg.bump = ctx.bumps.config;\n+        Ok(())\n+    }\n+\n+    pub fn set_enabled(ctx: Context<SetEnabled>, enabled: bool) -> Result<()> {\n+        ctx.accounts.config.enabled = enabled;\n+        Ok(())\n+    }\n+\n+    pub fn fund_reward_vault(ctx: Context<FundRewardVault>, amount: u64) -> Result<()> {\n+        require!(amount > 0, WitnessRewardsError::InvalidAmount);\n+        let cfg = &ctx.accounts.config;\n+\n+        validate_token_account(\n+            &ctx.accounts.funder_ata.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.funder.key(),\n+        )?;\n+        validate_token_account(\n+            &ctx.accounts.reward_vault.to_account_info(),\n+            &ctx.accounts.token_program.key(),\n+            &cfg.toll_mint,\n+            &ctx.accounts.vault_authority.key(),\n+        )?;\n+\n+        let ix = spl_token::instruction::transfer(\n+            &ctx.accounts.token_program.key(),\n+            &ctx.accounts.funder_ata.key(),\n+            &ctx.accounts.reward_vault.key(),\n+            &ctx.accounts.funder.key(),\n+            &[],\n+            amount,\n+        )?;\n+        invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.funder_ata.to_account_info(),\n+                ctx.accounts.reward_vault.to_account_info(),\n+                ctx.accounts.funder.to_account_info(),\n+                ctx.accounts.token_program.to_account_info(),\n+            ],\n+        )?;\n+        Ok(())\n+    }\n+\n+    pub fn deposit_bond(ctx: Context<DepositBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let ix = anchor_lang::solana_program::system_instruction::transfer(\n+            &ctx.accounts.miner.key(),\n+            &ctx.accounts.bond.key(),\n+            lamports,\n+        );\n+        anchor_lang::solana_program::program::invoke(\n+            &ix,\n+            &[\n+                ctx.accounts.miner.to_account_info(),\n+                ctx.accounts.bond.to_account_info(),\n+                ctx.accounts.system_program.to_account_info(),\n+            ],\n+        )?;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.miner = ctx.accounts.miner.key();\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_add(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = Clock::get()?.slot;\n+        bond.bump = ctx.bumps.bond;\n+        Ok(())\n+    }\n+\n+    pub fn withdraw_bond(ctx: Context<WithdrawBond>, lamports: u64) -> Result<()> {\n+        require!(lamports > 0, WitnessRewardsError::InvalidAmount);\n+        let now = Clock::get()?.slot;\n+\n+        let cfg = &ctx.accounts.config;\n+        let current = ctx.accounts.bond.to_account_info().lamports();\n+        let bond_view = &ctx.accounts.bond;\n+        require!(\n+            now >= bond_view.last_action_slot.saturating_add(cfg.cooldown_slots),\n+            WitnessRewardsError::CooldownNotMet\n+        );\n+        require!(bond_view.bond_lamports >= lamports, WitnessRewardsError::InsufficientBond);\n+\n+        let rent = Rent::get()?;\n+        let min_lamports = rent.minimum_balance(8 + MinerBond::SIZE);\n+        require!(\n+            current.saturating_sub(lamports) >= min_lamports,\n+            WitnessRewardsError::BondRentViolation\n+        );\n+\n+        **ctx.accounts.bond.to_account_info().try_borrow_mut_lamports()? -= lamports;\n+        **ctx.accounts.miner.to_account_info().try_borrow_mut_lamports()? += lamports;\n+\n+        let bond = &mut ctx.accounts.bond;\n+        bond.bond_lamports = bond\n+            .bond_lamports\n+            .checked_sub(lamports)\n+            .ok_or(error!(WitnessRewardsError::MathOverflow))?;\n+        bond.last_action_slot = now;\n+        Ok(())\n+    }\n+\n+    pub fn submit_receipt_batch(\n+        ctx: Context<SubmitReceiptBatch>,\n+        epoch_id: u64,\n+        receipts_root: [u8; 32],\n+        receipt_count: u32,\n+        unique_name_hashes: u32,\n+        unique_colos: u16,\n+    ) -> Result<()> {\n+        require!(ctx.accounts.config.enabled, WitnessRewardsError::Disabled);\n+        require!(receipt_count > 0, WitnessRewardsError::InvalidAmount);\n+\n+        let cfg = &ctx.accounts.config;\n+        let now_slot = Clock::get()?.slot;\n+        let current_epoch = now_slot / cfg.epoch_len_slots;\n+        require!(epoch_id == current_epoch, WitnessRewardsError::BadEpoch);\n+        require!(\n+            ctx.accounts.bond.bond_lamports >= cfg.min_bond_lamports,\n+            WitnessRewardsError::InsufficientBond\n+        );\n+\n+        let stats = &mut ctx.accounts.epoch_stats;\n+        if stats.miner == Pubkey::default() {\n+            stats.epoch_id = epoch_id;\n+            stats.miner = ctx.accounts.miner.key();\n+            stats.bump = ctx.bumps.epoch_stats;\n+        } else {\n+            require!(stats.miner == ctx.accounts.miner.key(), WitnessRewardsError::InvalidMiner);\n+            require!(stats.epoch_id == epoch_id, WitnessRewardsError::BadEpoch);\n+            require!(stats.last_receipts_root != receipts_root, WitnessRewardsError::DuplicateRoot);\n+            require!(!stats.claimed, WitnessRewardsError::AlreadyClaimed);\n+        }\n+\n+        let remaining_cap = cfg\n+            .max_rewardable_receipts_per_miner_per_epoch\n+            .saturating_sub(stats.rewardable_receipts);\n+        let rewardable = receipt_count.min(remaining_cap);\n+\n+        let diversity_bonus_bps = compute_diversity_bonus_bps(unique_name_hashes, unique_colos);","path":"solana/programs/ddns_witness_rewards/src/lib.rs","commit_id":"ef65e1974240a7dc34d317b6b4ae9f9fc4c0622a","original_commit_id":"cb9525550ac942cc1d9bd4712810c2e02c9bdc4f","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The diversity bonus is calculated using the per-batch unique_name_hashes and unique_colos values provided by the miner without verification. A malicious miner can inflate these values in every batch submission to maximize their rewards, even if the names and colos are identical across batches. The accumulated totals at lines 218-219 are stored but not used for bonus calculation - the bonus is calculated at line 191 using the raw, unverified inputs. This allows a miner to repeatedly claim diversity bonuses for the same data by splitting submissions into multiple batches. Consider either: (1) calculating the diversity bonus based on cumulative unique counts across all batches in an epoch, or (2) implementing cryptographic proof verification (e.g., Merkle proofs) to validate that the claimed unique counts match the receipts_root.\n```suggestion\n        // Compute diversity bonus based on cumulative unique counts across the epoch\n        let cumulative_unique_name_hashes = stats\n            .total_unique_name_hashes\n            .saturating_add(unique_name_hashes);\n        let cumulative_unique_colos = stats\n            .total_unique_colos\n            .saturating_add(unique_colos);\n\n        let diversity_bonus_bps =\n            compute_diversity_bonus_bps(cumulative_unique_name_hashes, cumulative_unique_colos);\n```","created_at":"2026-02-18T09:21:24Z","updated_at":"2026-02-18T09:21:24Z","html_url":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235116","pull_request_url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61","_links":{"self":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235116"},"html":{"href":"https://github.com/cwalinapj/DECENTRALIZED-DNS-/pull/61#discussion_r2821235116"},"pull_request":{"href":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/61"}},"reactions":{"url":"https://api.github.com/repos/cwalinapj/DECENTRALIZED-DNS-/pulls/comments/2821235116/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":191,"original_line":191,"side":"RIGHT","author_association":"NONE","original_position":191,"position":191,"subject_type":"line"}]